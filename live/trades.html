<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ“Š</text></svg>">
<title>PumpFun Live Trades â€” Real-Time Analytics Dashboard</title>
<meta name="description" content="Real-time Solana PumpFun trade analytics. Monitor buys, sells, token launches, migrations, and whale activity via WebSocket.">
<style>
  :root {
    --bg: #0a0a0a; --bg2: #111; --bg3: #1a1a1a; --border: #222;
    --green: #00ff41; --red: #ff4141; --yellow: #ffcc00; --blue: #4a9eff;
    --orange: #ff9900; --purple: #b366ff; --cyan: #00e5ff; --dim: #555; --text: #ccc;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: var(--bg); color: var(--green); font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.5; overflow-x: hidden; }

  /* â”€â”€ Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #app { display: grid; grid-template-rows: auto auto 1fr; height: 100vh; }

  /* â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #header {
    background: var(--bg2); border-bottom: 1px solid var(--border);
    padding: 10px 20px; display: flex; align-items: center; gap: 16px; flex-wrap: wrap;
    position: sticky; top: 0; z-index: 10;
  }
  #header h1 { font-size: 16px; white-space: nowrap; }
  .status { font-size: 12px; color: var(--dim); }
  .status.ok { color: var(--green); }
  .status.err { color: var(--red); }
  .controls { margin-left: auto; display: flex; gap: 8px; align-items: center; }
  button {
    background: var(--bg3); border: 1px solid #333; color: var(--green);
    padding: 5px 12px; cursor: pointer; font-family: inherit; font-size: 12px; border-radius: 3px;
  }
  button:hover { background: #252525; border-color: var(--green); }
  button.active { background: #002200; border-color: var(--green); }
  button.danger { color: var(--red); }
  button.danger:hover { border-color: var(--red); }
  select {
    background: var(--bg3); border: 1px solid #333; color: var(--text);
    padding: 5px 8px; font-family: inherit; font-size: 12px; border-radius: 3px;
  }
  input[type="text"] {
    background: var(--bg3); border: 1px solid #333; color: var(--text);
    padding: 5px 10px; font-family: inherit; font-size: 12px; border-radius: 3px; width: 200px;
  }
  input:focus, select:focus { outline: none; border-color: var(--green); }

  /* â”€â”€ Stats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #stats {
    background: #0d0d0d; border-bottom: 1px solid #1a1a1a;
    padding: 6px 20px; font-size: 11px; color: var(--dim);
    display: flex; gap: 20px; flex-wrap: wrap; align-items: center;
  }
  .val { color: var(--green); font-weight: bold; }
  .val.red { color: var(--red); }
  .val.yellow { color: var(--yellow); }
  .val.blue { color: var(--blue); }

  /* â”€â”€ Main Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #main {
    display: grid; grid-template-columns: 1fr 320px;
    overflow: hidden;
  }
  @media (max-width: 900px) { #main { grid-template-columns: 1fr; } #sidebar { display: none; } }

  /* â”€â”€ Feed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #feed { overflow-y: auto; padding: 0; }
  .trade {
    display: grid; grid-template-columns: 70px 50px 1fr 110px 100px 100px;
    gap: 8px; padding: 6px 20px; border-bottom: 1px solid #111; align-items: center;
    animation: fadeIn 0.2s ease; font-size: 12px;
  }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(-3px); } to { opacity: 1; } }
  .trade.buy { border-left: 2px solid var(--green); }
  .trade.sell { border-left: 2px solid var(--red); }
  .trade.create { border-left: 2px solid var(--yellow); }
  .trade.migrate { border-left: 2px solid var(--purple); }
  .trade.whale { background: rgba(255, 204, 0, 0.05); }
  .trade .time { color: #444; font-size: 11px; }
  .trade .type { font-weight: bold; text-transform: uppercase; font-size: 11px; }
  .trade .type.buy { color: var(--green); }
  .trade .type.sell { color: var(--red); }
  .trade .type.create { color: var(--yellow); }
  .trade .type.migrate { color: var(--purple); }
  .trade .token { color: var(--yellow); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .trade .amount { text-align: right; color: var(--text); }
  .trade .sol { text-align: right; }
  .trade .sol.pos { color: var(--green); }
  .trade .sol.neg { color: var(--red); }
  .trade .link { text-align: right; }
  .trade a { color: var(--blue); text-decoration: none; font-size: 11px; }
  .trade a:hover { text-decoration: underline; }
  .whale-tag { color: var(--yellow); font-size: 10px; margin-left: 4px; }

  /* â”€â”€ Sidebar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #sidebar {
    background: var(--bg2); border-left: 1px solid var(--border);
    overflow-y: auto; padding: 12px;
  }
  .panel { margin-bottom: 16px; }
  .panel h3 { font-size: 12px; color: var(--dim); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; border-bottom: 1px solid #222; padding-bottom: 4px; }
  .panel .row { display: flex; justify-content: space-between; padding: 3px 0; font-size: 12px; }
  .panel .row .label { color: #888; }

  /* â”€â”€ Volume Chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #chart-container { height: 100px; padding: 8px 0; }
  .bar-chart { display: flex; align-items: flex-end; gap: 2px; height: 80px; }
  .bar-chart .bar { flex: 1; min-width: 4px; border-radius: 1px 1px 0 0; transition: height 0.3s ease; position: relative; }
  .bar-chart .bar.buy { background: var(--green); }
  .bar-chart .bar.sell { background: var(--red); }
  .bar-chart .bar:hover { opacity: 0.7; }
  .chart-labels { display: flex; justify-content: space-between; font-size: 9px; color: #444; margin-top: 2px; }

  /* â”€â”€ Top Tokens â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .top-token { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #1a1a1a; font-size: 12px; }
  .top-token .name { color: var(--yellow); max-width: 140px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .top-token .trades { color: var(--text); }

  /* â”€â”€ Whale Alerts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .whale-alert {
    background: rgba(255, 204, 0, 0.08); border: 1px solid rgba(255, 204, 0, 0.2);
    border-radius: 4px; padding: 6px 8px; margin-bottom: 6px; font-size: 11px;
    animation: pulse 0.5s ease;
  }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
  .whale-alert .whale-sol { color: var(--yellow); font-weight: bold; }

  /* â”€â”€ System log line â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .sys { color: var(--dim); padding: 4px 20px; font-size: 11px; }
  .sys.error { color: var(--red); }
  .sys.warn { color: var(--yellow); }

  /* â”€â”€ Scrollbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  ::-webkit-scrollbar { width: 5px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: #222; border-radius: 3px; }
</style>
</head>
<body>

<div id="app">
  <div id="header">
    <h1>ğŸ“Š PumpFun Live Trades</h1>
    <a href="/" style="color:#4a9eff; text-decoration:none; font-size:12px; border:1px solid #333; padding:4px 10px; border-radius:3px;">âš¡ Token Launches</a>
    <a href="/vanity" style="color:#ffcc00; text-decoration:none; font-size:12px; border:1px solid #333; padding:4px 10px; border-radius:3px;">ğŸ”‘ Vanity Generator</a>
    <div class="status" id="status">â— Disconnected</div>
    <div class="controls">
      <select id="filter">
        <option value="all">All Events</option>
        <option value="buy">Buys Only</option>
        <option value="sell">Sells Only</option>
        <option value="create">Creates Only</option>
        <option value="whale">Whales Only (â‰¥1 SOL)</option>
      </select>
      <input type="text" id="search" placeholder="Filter by mint or token..." />
      <input type="text" id="rpc" placeholder="wss:// custom RPC endpoint" title="Paste your Helius / Quicknode / Triton WebSocket URL here" />
      <button id="btn-pause">Pause</button>
      <button id="btn-sound">ğŸ”‡</button>
      <button id="btn-demo" title="Simulate live trades for testing">Demo</button>
      <button id="btn-clear" class="danger">Clear</button>
    </div>
  </div>

  <div id="stats">
    <div>Events: <span class="val" id="s-total">0</span></div>
    <div>Buys: <span class="val" id="s-buys">0</span></div>
    <div>Sells: <span class="val red" id="s-sells">0</span></div>
    <div>Creates: <span class="val yellow" id="s-creates">0</span></div>
    <div>Whales: <span class="val yellow" id="s-whales">0</span></div>
    <div>Vol: <span class="val blue" id="s-volume">0</span> SOL</div>
    <div>Events/s: <span class="val" id="s-rate">0</span></div>
    <div>Uptime: <span class="val" id="s-uptime">0s</span></div>
  </div>

  <div id="main">
    <div id="feed">
      <!-- Column headers -->
      <div style="display:grid; grid-template-columns: 70px 50px 1fr 110px 100px 100px; gap:8px; padding:6px 20px; border-bottom:1px solid #333; font-size:11px; color:#555; text-transform:uppercase; letter-spacing:0.5px; position:sticky; top:0; background:var(--bg); z-index:1;">
        <span>Time</span><span>Type</span><span>Token</span><span style="text-align:right">Amount</span><span style="text-align:right">SOL</span><span style="text-align:right">Tx</span>
      </div>
    </div>

    <div id="sidebar">
      <!-- Volume Chart -->
      <div class="panel">
        <h3>ğŸ“ˆ Volume (30s windows)</h3>
        <div id="chart-container">
          <div class="bar-chart" id="chart"></div>
          <div class="chart-labels"><span>-5m</span><span>now</span></div>
        </div>
      </div>

      <!-- Buy/Sell Ratio -->
      <div class="panel">
        <h3>âš–ï¸ Buy/Sell Ratio</h3>
        <div id="ratio-bar" style="display:flex; height:8px; border-radius:4px; overflow:hidden; margin-bottom:6px;">
          <div id="ratio-buy" style="background:var(--green); width:50%; transition: width 0.5s;"></div>
          <div id="ratio-sell" style="background:var(--red); width:50%; transition: width 0.5s;"></div>
        </div>
        <div class="row"><span class="label">Buy %</span><span class="val" id="ratio-buy-pct">50%</span></div>
        <div class="row"><span class="label">Sell %</span><span class="val red" id="ratio-sell-pct">50%</span></div>
      </div>

      <!-- Top Tokens -->
      <div class="panel">
        <h3>ğŸ”¥ Top Tokens (by trades)</h3>
        <div id="top-tokens"></div>
      </div>

      <!-- Whale Alerts -->
      <div class="panel">
        <h3>ğŸ‹ Whale Alerts</h3>
        <div id="whale-alerts"><div style="color:#444; font-size:11px;">Waiting for whales...</div></div>
      </div>

      <!-- Connection Info -->
      <div class="panel">
        <h3>ğŸ”— Connection</h3>
        <div class="row"><span class="label">Program</span><span style="color:var(--blue); font-size:10px;">6EF8...F6P</span></div>
        <div class="row"><span class="label">Endpoint</span><span id="endpoint-display" style="color:var(--text); font-size:10px;">auto</span></div>
        <div class="row"><span class="label">Protocol</span><span id="protocol-display" style="color:var(--text);">â€”</span></div>
        <div class="row"><span class="label">Sub ID</span><span id="sub-id" style="color:var(--text);">â€”</span></div>
      </div>
    </div>
  </div>
</div>

<!-- Whale alert sound (web audio) -->
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PumpFun Live Trade Feed & Analytics Dashboard
// Real-time buy/sell/create/migrate detection via Solana RPC WebSocket
//
// Built with the Pump SDK (https://github.com/nirholas/pump-fun-sdk)
// Uses logsSubscribe to monitor the Pump program and parse events.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const PUMP_PROGRAM = '6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P';
const PUMP_AMM_PROGRAM = 'pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA';
const MAX_ENTRIES = 500;
const WHALE_THRESHOLD_LAMPORTS = 1_000_000_000; // 1 SOL
const CHART_BUCKETS = 10;  // 10 x 30s = 5 min
const BUCKET_MS = 30_000;

// â”€â”€ Endpoints (tried in order) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PumpPortal is a free, purpose-built WebSocket API for Pump.fun trades.
// The Railway relay server proxies Solana RPC logsSubscribe and re-
// broadcasts parsed events, avoiding public RPC rate limits.
// Public Solana RPCs reject logsSubscribe for high-traffic programs,
// so they are only useful if the user enters a paid RPC URL.
const RPC_ENDPOINTS = [
  { url: 'wss://pumpportal.fun/api/data',                          protocol: 'pumpportal', label: 'PumpPortal' },
  { url: 'wss://pump-fun-websocket-production.up.railway.app/ws',  protocol: 'relay',      label: 'Relay Server' },
];
const MAX_FULL_CYCLES = 2; // auto-demo after this many full rotations
let rpcIndex = 0;

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let ws = null;
let subId = null;
let paused = false;
let soundEnabled = false;
let startTime = 0;
let reconnectDelay = 1000;
let reconnectTimer = null;
let manualDisconnect = false;
let rateInterval = null;
let connectAttempts = 0;
let currentProtocol = null; // 'pumpportal' | 'solana-rpc'
let demoMode = false;
let demoInterval = null;

const stats = {
  total: 0, buys: 0, sells: 0, creates: 0, migrates: 0, whales: 0,
  volumeLamports: 0, logsReceived: 0,
};

// Token activity tracking
const tokenMap = new Map(); // mint -> { name, symbol, buys, sells, volume }

// Volume chart: each bucket tracks { buys, sells, buyVol, sellVol, ts }
const chartData = Array.from({ length: CHART_BUCKETS }, (_, i) => ({
  buys: 0, sells: 0, buyVol: 0, sellVol: 0, ts: Date.now() - (CHART_BUCKETS - 1 - i) * BUCKET_MS,
}));

// Whale alerts (last 20)
const whaleAlerts = [];

// â”€â”€ DOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const $feed = document.getElementById('feed');
const $status = document.getElementById('status');
const $filter = document.getElementById('filter');
const $search = document.getElementById('search');
const $btnPause = document.getElementById('btn-pause');
const $btnSound = document.getElementById('btn-sound');
const $btnClear = document.getElementById('btn-clear');
const $rpc = document.getElementById('rpc');

// â”€â”€ Audio context (whale sound) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let audioCtx = null;
function playWhaleSound() {
  if (!soundEnabled) return;
  try {
    if (!audioCtx) audioCtx = new AudioContext();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.type = 'sine'; osc.frequency.value = 440;
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
    osc.start(); osc.stop(audioCtx.currentTime + 0.5);
  } catch {}
}

// â”€â”€ Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
$btnPause.onclick = () => {
  paused = !paused;
  $btnPause.textContent = paused ? 'Resume' : 'Pause';
  $btnPause.classList.toggle('active', paused);
};
$btnSound.onclick = () => {
  soundEnabled = !soundEnabled;
  $btnSound.textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
  if (soundEnabled && !audioCtx) audioCtx = new AudioContext();
};
$btnClear.onclick = () => {
  // Keep header row, remove everything else
  while ($feed.children.length > 1) $feed.removeChild($feed.lastChild);
};

// â”€â”€ Demo Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const $btnDemo = document.getElementById('btn-demo');
$btnDemo.onclick = () => {
  demoMode = !demoMode;
  $btnDemo.classList.toggle('active', demoMode);
  $btnDemo.textContent = demoMode ? 'Demo â—' : 'Demo';
  if (demoMode) {
    // Disconnect real feed
    manualDisconnect = true;
    if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
    if (ws) { try { ws.close(); } catch {} }
    setStatus('â— Demo Mode', 'ok');
    document.getElementById('endpoint-display').textContent = 'simulated';
    document.getElementById('protocol-display').textContent = 'demo';
    sysLog('Demo mode ON â€” generating simulated Pump.fun trades');
    if (!startTime) startTime = Date.now();
    startRateCounter();
    startDemo();
  } else {
    stopDemo();
    sysLog('Demo mode OFF â€” reconnecting...');
    manualDisconnect = false;
    connect();
  }
};

const DEMO_TOKENS = [
  { name: 'MOONCAT', symbol: 'MOON', mint: '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU' },
  { name: 'SOLAPE', symbol: 'SAPE', mint: '9dFkba3aBZq4y2eRYBAmQszYvisWikJC3WAXjUZr8pumP' },
  { name: 'DEGENWIF', symbol: 'DWIF', mint: '3mPz8jQ7GkNPhzA3mXQthVK7dBqpHDJmR69FQxhK7nGR' },
  { name: 'FROGGY', symbol: 'FROG', mint: 'A1b2C3d4E5f6G7h8I9j0K1L2M3N4O5P6Q7R8S9T0U1V2' },
  { name: 'PUMPIT', symbol: 'PUMP', mint: 'ZzYyXxWwVvUuTtSsRrQqPpOoNnMmLlKkJjIiHhGgFfEe' },
  { name: 'BONKINU', symbol: 'BINU', mint: 'D4e5F6g7H8i9J0k1L2m3N4o5P6q7R8s9T0u1V2w3X4y5' },
  { name: 'SOLTOSHI', symbol: 'STSH', mint: 'Q1w2E3r4T5y6U7i8O9p0A1s2D3f4G5h6J7k8L9z0X1c2' },
  { name: 'AIDOG', symbol: 'ADOG', mint: 'M1n2B3v4C5x6Z7l8K9j0H1g2F3d4S5a6P7o8I9u0Y1t2' },
];

function startDemo() {
  demoInterval = setInterval(() => {
    const token = DEMO_TOKENS[Math.floor(Math.random() * DEMO_TOKENS.length)];
    const isBuy = Math.random() > 0.4;
    const isCreate = Math.random() < 0.05;
    const isMigrate = !isCreate && Math.random() < 0.02;
    const type = isCreate ? 'create' : isMigrate ? 'migrate' : isBuy ? 'buy' : 'sell';
    const solLamports = Math.floor((Math.random() * 5 + 0.01) * 1e9);
    const tokenAmount = Math.floor(Math.random() * 1e10);

    const event = {
      type,
      signature: Array.from({ length: 88 }, () => 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz123456789'[Math.floor(Math.random() * 58)]).join(''),
      time: new Date().toLocaleTimeString(),
      mint: token.mint,
      solLamports,
      tokenAmount,
      trader: null,
      tokenName: token.name,
      tokenSymbol: token.symbol,
    };

    ingestEvent(event);
  }, 300 + Math.floor(Math.random() * 700));
}

function stopDemo() {
  if (demoInterval) { clearInterval(demoInterval); demoInterval = null; }
}

// â”€â”€ WebSocket Connection (PumpPortal primary, Solana RPC fallback) â”€â”€â”€
function getNextEndpoint() {
  // If the user typed a custom URL, always use that
  const custom = $rpc.value.trim();
  if (custom && (custom.startsWith('wss://') || custom.startsWith('ws://'))) {
    const proto = custom.includes('pumpportal') ? 'pumpportal' : 'solana-rpc';
    return { url: custom, protocol: proto, label: 'Custom' };
  }
  // Otherwise rotate through built-in list
  const ep = RPC_ENDPOINTS[rpcIndex % RPC_ENDPOINTS.length];
  rpcIndex++;
  return ep;
}

function connect() {
  if (demoMode) return;
  if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
  const ep = getNextEndpoint();
  const url = ep.url;
  currentProtocol = ep.protocol;
  manualDisconnect = false;
  connectAttempts++;
  const shortUrl = url.replace(/api-key=\w+/, 'api-key=***').slice(0, 60);
  setStatus('Connecting...', '');
  sysLog(`Connecting to ${ep.label} (${shortUrl})...`);

  try {
    ws = new WebSocket(url);
  } catch (e) {
    sysLog(`Invalid WebSocket URL: ${e.message}`, 'error');
    scheduleReconnect();
    return;
  }

  // Timeout â€” if no open within 10s, try next endpoint
  const connectTimeout = setTimeout(() => {
    if (ws && ws.readyState !== WebSocket.OPEN) {
      sysLog(`Connection timeout for ${ep.label}, trying next...`, 'warn');
      try { ws.close(); } catch {}
    }
  }, 10000);

  ws.onopen = () => {
    clearTimeout(connectTimeout);
    reconnectDelay = 1000;
    connectAttempts = 0;
    setStatus('â— Subscribing...', 'ok');
    document.getElementById('endpoint-display').textContent = ep.label;
    document.getElementById('protocol-display').textContent = currentProtocol;
    if (!startTime) startTime = Date.now();
    startRateCounter();

    if (currentProtocol === 'pumpportal') {
      // PumpPortal: subscribe to all new tokens + all token trades
      ws.send(JSON.stringify({ method: 'subscribeNewToken' }));
      ws.send(JSON.stringify({ method: 'subscribeTokenTrade', keys: ['all'] }));
      setStatus('â— Live â€” PumpPortal', 'ok');
      document.getElementById('sub-id').textContent = 'stream';
      sysLog('Subscribed via PumpPortal â€” streaming all trades + new tokens');
    } else if (currentProtocol === 'relay') {
      // Railway relay: already subscribed server-side, just listen
      setStatus('â— Live â€” Relay', 'ok');
      document.getElementById('sub-id').textContent = 'relay';
      sysLog('Connected to relay server â€” receiving proxied events');
    } else {
      // Solana RPC: subscribe to program logs
      ws.send(JSON.stringify({
        jsonrpc: '2.0', id: 1,
        method: 'logsSubscribe',
        params: [{ mentions: [PUMP_PROGRAM] }, { commitment: 'confirmed' }],
      }));
    }
  };

  ws.onmessage = (evt) => {
    let msg;
    try { msg = JSON.parse(evt.data); } catch { return; }

    if (currentProtocol === 'pumpportal') {
      handlePumpPortalMessage(msg);
      return;
    }

    if (currentProtocol === 'relay') {
      handleRelayMessage(msg);
      return;
    }

    // â”€â”€ Solana RPC protocol â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Subscription confirmation
    if (msg.id === 1 && msg.result !== undefined) {
      subId = msg.result;
      setStatus(`â— Live â€” sub:${subId}`, 'ok');
      document.getElementById('sub-id').textContent = subId;
      sysLog(`Subscribed (id=${subId}). Monitoring all Pump trades...`);
      return;
    }

    // RPC error (some endpoints reject logsSubscribe)
    if (msg.id === 1 && msg.error) {
      sysLog(`RPC rejected logsSubscribe: ${msg.error.message || JSON.stringify(msg.error)}`, 'error');
      sysLog('Tip: public RPCs rate-limit logsSubscribe. Try PumpPortal or a paid RPC.', 'warn');
      try { ws.close(); } catch {}
      return;
    }

    if (msg.method === 'logsNotify' && msg.params?.result) {
      stats.logsReceived++;
      processNotification(msg.params.result);
    }
  };

  ws.onerror = () => {
    clearTimeout(connectTimeout);
    setStatus('â— Error', 'err');
    sysLog(`WebSocket error on ${ep.label}`, 'error');
  };

  ws.onclose = (evt) => {
    clearTimeout(connectTimeout);
    ws = null; subId = null; currentProtocol = null;
    document.getElementById('sub-id').textContent = 'â€”';
    document.getElementById('protocol-display').textContent = 'â€”';
    if (!manualDisconnect) {
      scheduleReconnect();
    } else {
      setStatus('â— Disconnected', '');
      stopRateCounter();
    }
  };
}

function scheduleReconnect() {
  if (demoMode) return;

  // After cycling all endpoints MAX_FULL_CYCLES times, auto-switch to demo
  const fullCycles = Math.floor(connectAttempts / RPC_ENDPOINTS.length);
  if (fullCycles >= MAX_FULL_CYCLES) {
    sysLog('All endpoints unreachable â€” switching to Demo mode automatically', 'error');
    sysLog('Tip: enter a paid Solana RPC URL (wss://â€¦) and press Enter to reconnect', 'warn');
    $btnDemo.click();
    return;
  }

  const delay = Math.min(reconnectDelay, 15000);
  const nextEp = RPC_ENDPOINTS[rpcIndex % RPC_ENDPOINTS.length];
  setStatus(`â— Retrying ${(delay / 1000).toFixed(0)}s â†’ ${nextEp.label}`, 'err');
  sysLog(`Trying ${nextEp.label} in ${(delay / 1000).toFixed(0)}s...`, 'warn');
  reconnectTimer = setTimeout(connect, delay);
  // Increase delay after cycling all endpoints once
  if (connectAttempts >= RPC_ENDPOINTS.length) {
    reconnectDelay = Math.min(reconnectDelay * 1.5, 15000);
  }
}

// â”€â”€ PumpPortal message handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handlePumpPortalMessage(msg) {
  // PumpPortal sends flat JSON objects with txType, mint, solAmount, etc.
  if (!msg || typeof msg !== 'object') return;
  stats.logsReceived++;

  // Determine event type
  const txType = (msg.txType || '').toLowerCase();
  let type = null;
  if (txType === 'buy') type = 'buy';
  else if (txType === 'sell') type = 'sell';
  else if (txType === 'create') type = 'create';
  else if (txType === 'migrate') type = 'migrate';
  else if (msg.mint && msg.name && !msg.txType) type = 'create'; // subscribeNewToken events
  else return; // Unknown message type

  // Normalize amounts â€” PumpPortal may send solAmount in lamports or SOL
  let solLamports = 0;
  if (msg.solAmount !== undefined) {
    solLamports = msg.solAmount > 1e6 ? Math.floor(msg.solAmount) : Math.floor(msg.solAmount * 1e9);
  } else if (msg.vSolInBondingCurve !== undefined && type === 'create') {
    solLamports = 0; // Creates don't have a trade amount
  }

  let tokenAmount = 0;
  if (msg.tokenAmount !== undefined) {
    tokenAmount = Math.floor(msg.tokenAmount);
  }

  const event = {
    type,
    signature: msg.signature || '',
    time: new Date().toLocaleTimeString(),
    mint: msg.mint || 'unknown',
    solLamports,
    tokenAmount,
    trader: msg.traderPublicKey || null,
    tokenName: msg.name || null,
    tokenSymbol: msg.symbol || null,
  };

  ingestEvent(event);
}

// â”€â”€ Railway relay server message handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleRelayMessage(msg) {
  if (!msg || typeof msg !== 'object') return;
  // Skip heartbeat / status frames
  if (msg.type === 'heartbeat' || msg.type === 'status') return;
  // The relay emits TokenLaunchEvent objects with type='token-launch'
  if (msg.type === 'token-launch' || msg.type === 'create' || msg.mint) {
    stats.logsReceived++;
    const event = {
      type: 'create',
      signature: msg.signature || '',
      time: new Date().toLocaleTimeString(),
      mint: msg.mint || 'unknown',
      solLamports: 0,
      tokenAmount: 0,
      trader: msg.creator || null,
      tokenName: msg.name || null,
      tokenSymbol: msg.symbol || null,
    };
    ingestEvent(event);
  }
}

// â”€â”€ Process a Solana RPC log notification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function processNotification(result) {
  const { value } = result;
  if (!value || value.err) return;
  const { signature, logs } = value;
  if (!logs?.length) return;

  const logsText = logs.join('\n');
  const event = classifyEvent(logsText, logs, signature);
  if (!event) return;

  ingestEvent(event);
}

// â”€â”€ Common event ingestion (used by all sources) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function ingestEvent(event) {
  stats.total++;

  // Update type counters
  if (event.type === 'buy') stats.buys++;
  else if (event.type === 'sell') stats.sells++;
  else if (event.type === 'create') stats.creates++;
  else if (event.type === 'migrate') stats.migrates++;

  // Volume tracking
  if (event.solLamports > 0) {
    stats.volumeLamports += event.solLamports;
  }

  // Whale detection
  const isWhale = event.solLamports >= WHALE_THRESHOLD_LAMPORTS;
  if (isWhale) {
    stats.whales++;
    addWhaleAlert(event);
    playWhaleSound();
  }

  // Token tracking
  trackToken(event);

  // Chart data
  updateChart(event);

  // Apply filters
  const filterVal = $filter.value;
  const searchVal = $search.value.toLowerCase();
  let show = true;
  if (filterVal === 'buy' && event.type !== 'buy') show = false;
  if (filterVal === 'sell' && event.type !== 'sell') show = false;
  if (filterVal === 'create' && event.type !== 'create') show = false;
  if (filterVal === 'whale' && !isWhale) show = false;
  if (searchVal && !event.mint?.toLowerCase().includes(searchVal) &&
      !event.tokenName?.toLowerCase().includes(searchVal)) show = false;

  if (!paused && show) renderTrade(event, isWhale);
  updateAllStats();
}

// â”€â”€ Borsh readers for Anchor events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function readBorshStr(buf, off) {
  if (off + 4 > buf.length) return { v: '', e: off };
  const len = buf[off] | (buf[off+1] << 8) | (buf[off+2] << 16) | (buf[off+3] << 24);
  off += 4;
  if (len <= 0 || len > 1000 || off + len > buf.length) return { v: '', e: off };
  return { v: new TextDecoder().decode(buf.slice(off, off + len)), e: off + len };
}
function readPk(buf, off) {
  if (off + 32 > buf.length) return { v: '', e: off };
  return { v: bytesToBase58(buf.slice(off, off + 32)), e: off + 32 };
}
function readU64(buf, off) {
  if (off + 8 > buf.length) return { v: 0, e: off };
  const dv = new DataView(buf.buffer, buf.byteOffset + off, 8);
  return { v: Number(dv.getBigUint64(0, true)), e: off + 8 };
}

// â”€â”€ Classify event type from program logs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function classifyEvent(logsText, logs, signature) {
  let type = null;
  let solLamports = 0;
  let tokenAmount = 0;
  let mint = null;
  let trader = null;
  let tokenName = null;
  let tokenSymbol = null;

  if (logsText.includes('Instruction: Sell')) type = 'sell';
  else if (logsText.includes('Instruction: Buy')) type = 'buy';
  else if (logsText.includes('Instruction: Create')) type = 'create';
  else if (logsText.includes('Instruction: Migrate')) type = 'migrate';
  else return null;

  for (const line of logs) {
    if (!line.startsWith('Program data: ')) {
      if (line.includes('Program log: mint:') && !mint) {
        const m = line.match(/mint:\s*(\w{32,})/);
        if (m) mint = m[1];
      }
      continue;
    }
    try {
      const b64 = line.slice('Program data: '.length).trim();
      const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));

      if (type === 'create' && bytes.length > 50) {
        // CreateEvent: disc(8) + name(str) + symbol(str) + uri(str) + mint(32) + ...
        let off = 8;
        const name = readBorshStr(bytes, off); off = name.e;
        const sym = readBorshStr(bytes, off); off = sym.e;
        const uri = readBorshStr(bytes, off); off = uri.e;
        const mk = readPk(bytes, off); off = mk.e;
        const bc = readPk(bytes, off); off = bc.e;
        const usr = readPk(bytes, off); off = usr.e;
        if (name.v) tokenName = name.v;
        if (sym.v) tokenSymbol = sym.v;
        if (mk.v && mk.v.length >= 32) mint = mk.v;
        if (usr.v && usr.v.length >= 32) trader = usr.v;
        if (uri.v) fetchTokenMeta(uri.v, signature, mint);
      } else if ((type === 'buy' || type === 'sell') && bytes.length >= 81) {
        // TradeEvent: disc(8) + mint(32) + sol(8) + token(8) + is_buy(1) + user(32)
        const mk = readPk(bytes, 8);
        if (mk.v && mk.v.length >= 32) mint = mk.v;
        const sol = readU64(bytes, 40); solLamports = sol.v > 1e18 ? 0 : sol.v;
        const tok = readU64(bytes, 48); tokenAmount = tok.v > 1e30 ? 0 : tok.v;
        const usr = readPk(bytes, 57);
        if (usr.v && usr.v.length >= 32) trader = usr.v;
        // Look up cached name
        if (mint && tokenMap.has(mint)) {
          const t = tokenMap.get(mint);
          if (t.name) tokenName = t.name;
          if (t.symbol) tokenSymbol = t.symbol;
        }
      }
    } catch {}
  }

  return { type, signature, time: new Date().toLocaleTimeString(),
    mint: mint || 'unknown', solLamports, tokenAmount, trader, tokenName, tokenSymbol };
}

// â”€â”€ Base58 encoder (minimal, for display) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const B58_ALPHA = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
function bytesToBase58(bytes) {
  // Simple base58 for 32-byte keys
  let num = BigInt(0);
  for (const b of bytes) num = num * 256n + BigInt(b);
  if (num === 0n) return '1';
  let str = '';
  while (num > 0n) {
    str = B58_ALPHA[Number(num % 58n)] + str;
    num = num / 58n;
  }
  // Leading zeros
  for (const b of bytes) { if (b === 0) str = '1' + str; else break; }
  return str;
}

// â”€â”€ Fetch token metadata (best-effort) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fetchTokenMeta(uri, signature, mint) {
  try {
    let url = uri;
    if (url.startsWith('ipfs://')) url = 'https://cf-ipfs.com/ipfs/' + url.slice(7);
    const resp = await fetch(url, { signal: AbortSignal.timeout(5000) });
    if (!resp.ok) return;
    const meta = await resp.json();
    if (mint) {
      const t = tokenMap.get(mint);
      if (t) {
        if (meta.name) t.name = meta.name;
        if (meta.symbol) t.symbol = meta.symbol;
      }
      // Update visible entry
      const el = document.getElementById('tx-' + signature.slice(0, 16));
      if (el) {
        const nameEl = el.querySelector('.token');
        if (nameEl) {
          let display = meta.name || '';
          if (meta.symbol) display += ' $' + meta.symbol;
          if (display) {
            nameEl.innerHTML = `<a href="https://pump.fun/coin/${mint}" target="_blank" title="${mint}">${display}</a>`;
          }
        }
      }
    }
  } catch {}
}

// â”€â”€ Track token activity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function trackToken(event) {
  const key = event.mint;
  if (key === 'unknown') return;
  if (!tokenMap.has(key)) {
    tokenMap.set(key, { name: event.tokenName || key.slice(0, 8) + '...', symbol: event.tokenSymbol || '', buys: 0, sells: 0, volume: 0, lastSeen: Date.now() });
  }
  const t = tokenMap.get(key);
  if (event.tokenName && t.name.endsWith('...')) t.name = event.tokenName; // update if we got a real name
  if (event.tokenSymbol && !t.symbol) t.symbol = event.tokenSymbol;
  if (event.type === 'buy') t.buys++;
  if (event.type === 'sell') t.sells++;
  t.volume += event.solLamports;
  t.lastSeen = Date.now();
}

// â”€â”€ Update volume chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateChart(event) {
  const now = Date.now();
  const bucket = chartData[chartData.length - 1];

  // Roll buckets if needed
  if (now - bucket.ts > BUCKET_MS) {
    chartData.shift();
    chartData.push({ buys: 0, sells: 0, buyVol: 0, sellVol: 0, ts: now });
  }

  const cur = chartData[chartData.length - 1];
  if (event.type === 'buy') { cur.buys++; cur.buyVol += event.solLamports; }
  if (event.type === 'sell') { cur.sells++; cur.sellVol += event.solLamports; }

  renderChart();
}

// â”€â”€ Render chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderChart() {
  const $chart = document.getElementById('chart');
  const maxCount = Math.max(1, ...chartData.map(b => Math.max(b.buys, b.sells)));
  $chart.innerHTML = chartData.map(b => {
    const buyH = Math.max(1, (b.buys / maxCount) * 70);
    const sellH = Math.max(1, (b.sells / maxCount) * 70);
    return `<div style="display:flex; flex-direction:column; gap:1px; flex:1; align-items:stretch; justify-content:flex-end; height:80px;">
      <div class="bar buy" style="height:${buyH}px;" title="Buys: ${b.buys}"></div>
      <div class="bar sell" style="height:${sellH}px;" title="Sells: ${b.sells}"></div>
    </div>`;
  }).join('');
}

// â”€â”€ Add whale alert â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addWhaleAlert(event) {
  const sol = (event.solLamports / 1e9).toFixed(2);
  const alert = { type: event.type, sol, mint: event.mint, name: event.tokenName || null, time: event.time, sig: event.signature };
  whaleAlerts.unshift(alert);
  if (whaleAlerts.length > 10) whaleAlerts.pop();
  renderWhaleAlerts();
}

function renderWhaleAlerts() {
  const $el = document.getElementById('whale-alerts');
  $el.innerHTML = whaleAlerts.map(a => {
    const emoji = a.type === 'buy' ? 'ğŸŸ¢' : a.type === 'sell' ? 'ğŸ”´' : 'ğŸŸ¡';
    const display = a.name || (a.mint.slice(0, 6) + '...' + a.mint.slice(-4));
    return `<div class="whale-alert">
      ${emoji} <span class="whale-sol">${a.sol} SOL</span> ${a.type.toUpperCase()}
      <span style="color:#888">${display}</span>
      <a href="https://solscan.io/tx/${a.sig}" target="_blank" style="color:var(--blue); text-decoration:none; font-size:10px; float:right;">view tx</a>
    </div>`;
  }).join('');
}

// â”€â”€ Render a trade row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTrade(event, isWhale) {
  const sol = event.solLamports > 0 ? (event.solLamports / 1e9).toFixed(4) : 'â€”';
  const tokens = event.tokenAmount > 0 ? formatTokenAmount(event.tokenAmount) : 'â€”';
  const shortSig = event.signature.slice(0, 6) + 'â€¦' + event.signature.slice(-4);
  const shortMint = event.mint !== 'unknown' ? event.mint.slice(0, 4) + 'â€¦' + event.mint.slice(-4) : 'â€”';

  // Build display name: "Name ($SYM)" or "Name" or shortened mint
  let displayName = shortMint;
  if (event.tokenName) {
    displayName = event.tokenName;
    if (event.tokenSymbol) displayName += ' $' + event.tokenSymbol;
  } else if (event.tokenSymbol) {
    displayName = '$' + event.tokenSymbol;
  }

  const div = document.createElement('div');
  div.className = `trade ${event.type}${isWhale ? ' whale' : ''}`;
  div.id = 'tx-' + event.signature.slice(0, 16);

  const solClass = event.type === 'buy' ? 'pos' : event.type === 'sell' ? 'neg' : '';
  const mintLink = event.mint !== 'unknown'
    ? `<a href="https://pump.fun/coin/${event.mint}" target="_blank" title="${event.mint}">${displayName}</a>`
    : displayName;

  div.innerHTML =
    `<span class="time">${event.time}</span>` +
    `<span class="type ${event.type}">${event.type}${isWhale ? '<span class="whale-tag">ğŸ‹</span>' : ''}</span>` +
    `<span class="token">${mintLink}</span>` +
    `<span class="amount">${tokens}</span>` +
    `<span class="sol ${solClass}">${event.type === 'sell' ? '-' : ''}${sol}</span>` +
    `<span class="link"><a href="https://solscan.io/tx/${event.signature}" target="_blank">${shortSig}</a></span>`;

  if ($feed.children.length > 1) {
    $feed.insertBefore(div, $feed.children[1]);
  } else {
    $feed.appendChild(div);
  }

  while ($feed.children.length > MAX_ENTRIES + 1) {
    $feed.removeChild($feed.lastChild);
  }
}

function formatTokenAmount(raw) {
  if (raw >= 1e12) return (raw / 1e12).toFixed(1) + 'T';
  if (raw >= 1e9) return (raw / 1e9).toFixed(1) + 'B';
  if (raw >= 1e6) return (raw / 1e6).toFixed(1) + 'M';
  if (raw >= 1e3) return (raw / 1e3).toFixed(1) + 'K';
  return raw.toString();
}

// â”€â”€ Update all stats & sidebar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateAllStats() {
  document.getElementById('s-total').textContent = stats.total;
  document.getElementById('s-buys').textContent = stats.buys;
  document.getElementById('s-sells').textContent = stats.sells;
  document.getElementById('s-creates').textContent = stats.creates;
  document.getElementById('s-whales').textContent = stats.whales;
  document.getElementById('s-volume').textContent = (stats.volumeLamports / 1e9).toFixed(2);

  // Buy/sell ratio
  const total = stats.buys + stats.sells || 1;
  const buyPct = Math.round((stats.buys / total) * 100);
  const sellPct = 100 - buyPct;
  document.getElementById('ratio-buy').style.width = buyPct + '%';
  document.getElementById('ratio-sell').style.width = sellPct + '%';
  document.getElementById('ratio-buy-pct').textContent = buyPct + '%';
  document.getElementById('ratio-sell-pct').textContent = sellPct + '%';

  // Top tokens (by trade count, top 8)
  updateTopTokens();
}

function updateTopTokens() {
  const sorted = [...tokenMap.entries()]
    .map(([mint, t]) => ({ mint, ...t, total: t.buys + t.sells }))
    .sort((a, b) => b.total - a.total)
    .slice(0, 8);

  document.getElementById('top-tokens').innerHTML = sorted.length === 0
    ? '<div style="color:#444; font-size:11px;">Waiting for trades...</div>'
    : sorted.map(t => {
        const shortMint = t.mint.slice(0, 4) + 'â€¦' + t.mint.slice(-4);
        const display = t.name && !t.name.endsWith('...') ? t.name + (t.symbol ? ' $' + t.symbol : '') : shortMint;
        const vol = (t.volume / 1e9).toFixed(2);
        return `<div class="top-token">
          <a class="name" href="https://pump.fun/coin/${t.mint}" target="_blank" title="${t.mint}" style="color:#ffcc00;text-decoration:none;">${display}</a>
          <span class="trades">${t.total} trades Â· ${vol} SOL</span>
        </div>`;
      }).join('');
}

// â”€â”€ System log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sysLog(msg, level = '') {
  const div = document.createElement('div');
  div.className = 'sys' + (level ? ' ' + level : '');
  div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
  if ($feed.children.length > 1) {
    $feed.insertBefore(div, $feed.children[1]);
  } else {
    $feed.appendChild(div);
  }
}

// â”€â”€ Rate counter / uptime â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startRateCounter() {
  let prev = 0;
  rateInterval = setInterval(() => {
    const rate = stats.logsReceived - prev;
    prev = stats.logsReceived;
    document.getElementById('s-rate').textContent = rate;

    if (startTime) {
      const sec = Math.floor((Date.now() - startTime) / 1000);
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = sec % 60;
      document.getElementById('s-uptime').textContent =
        h > 0 ? `${h}h ${m}m` : m > 0 ? `${m}m ${s}s` : `${s}s`;
    }

    // Roll chart buckets periodically
    const bucket = chartData[chartData.length - 1];
    if (Date.now() - bucket.ts > BUCKET_MS) {
      chartData.shift();
      chartData.push({ buys: 0, sells: 0, buyVol: 0, sellVol: 0, ts: Date.now() });
      renderChart();
    }
  }, 1000);
}

function stopRateCounter() {
  if (rateInterval) { clearInterval(rateInterval); rateInterval = null; }
}

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setStatus(text, cls) {
  $status.textContent = text;
  $status.className = 'status' + (cls ? ' ' + cls : '');
}

// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
renderChart();
sysLog('PumpFun Live Trades â€” Real-time analytics dashboard');
sysLog(`Monitoring Pump program: ${PUMP_PROGRAM}`);
sysLog(`Primary: PumpPortal API (pre-parsed trades, no RPC limits)`);
sysLog(`Fallback: Relay server at Railway (proxied Solana events)`);
sysLog(`Auto-demo after ${MAX_FULL_CYCLES} full endpoint cycles if all fail`);
sysLog('Tracking: buys, sells, creates, migrations, whale alerts (â‰¥1 SOL)');
sysLog('Click "Demo" to simulate trades if all endpoints are unavailable');

// Allow Enter in RPC input to force reconnect
$rpc.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    if (demoMode) { $btnDemo.click(); } // exit demo mode
    reconnectDelay = 1000;
    connectAttempts = 0;
    rpcIndex = 0;
    if (ws) { manualDisconnect = true; try { ws.close(); } catch {} }
    setTimeout(connect, 100);
  }
});

connect();
</script>
</body>
</html>
