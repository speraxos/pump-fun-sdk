/// <reference types="@cloudflare/workers-types" />

/**
 * Cloudflare Workers entry point for the Solana Wallet MCP Server.
 *
 * Uses Cloudflare Durable Objects via the `agents` SDK to maintain
 * per-session state (generated keypairs) across MCP protocol messages.
 *
 * Endpoints:
 *   GET  /sse            — SSE transport (connect)
 *   POST /sse/message    — SSE transport (send message)
 *   POST /mcp            — Streamable HTTP transport
 *   GET  /               — Health / info JSON
 */

import { McpAgent } from "agents/mcp";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import type { ServerState } from "./types/index.js";
import { handleToolCall } from "./tools/index.js";
import { handleGetPrompt } from "./prompts/index.js";
import { TOOLS } from "./handlers/tools.js";
import { PROMPTS } from "./handlers/prompts.js";

// ---------------------------------------------------------------------------
// Environment bindings (generated by `wrangler types`)
// ---------------------------------------------------------------------------

type Env = {
  MCP_OBJECT: DurableObjectNamespace<SolanaWalletMCP>;
};

// ---------------------------------------------------------------------------
// JSON-Schema → Zod conversion helpers
// ---------------------------------------------------------------------------

/** Convert a single JSON Schema property definition to a Zod type. */
function jsonPropToZod(
  prop: Record<string, unknown>,
  required: boolean,
): z.ZodTypeAny {
  let s: z.ZodTypeAny;
  switch (prop.type) {
    case "string":
      s = z.string();
      break;
    case "number":
      s = z.number();
      break;
    case "boolean":
      s = z.boolean();
      break;
    default:
      s = z.unknown();
  }
  return required ? s : s.optional();
}

/** Convert the JSON Schema `inputSchema` of a tool to a Zod raw shape. */
function toZodShape(schema: {
  type: string;
  properties: Record<string, unknown>;
  required?: string[];
}): z.ZodRawShape {
  const req = new Set(schema.required ?? []);
  const shape: z.ZodRawShape = {};
  for (const [key, val] of Object.entries(schema.properties)) {
    shape[key] = jsonPropToZod(val as Record<string, unknown>, req.has(key));
  }
  return shape;
}

// ---------------------------------------------------------------------------
// Durable Object — MCP Agent
// ---------------------------------------------------------------------------

export class SolanaWalletMCP extends McpAgent<Env> {
  server = new McpServer({
    name: "solana-wallet-toolkit",
    version: "1.0.0",
  });

  /** Per-session state — lives as long as the Durable Object instance. */
  private mcpState: ServerState = {
    initialized: false,
    clientCapabilities: {},
    generatedKeypairs: new Map(),
  };

  async init() {
    // ── Tools ────────────────────────────────────────────────────────
    for (const tool of TOOLS) {
      const shape = toZodShape(tool.inputSchema);
      this.server.tool(
        tool.name,
        tool.description,
        shape,
        async (args: Record<string, unknown>) =>
          handleToolCall(tool.name, args, this.mcpState) as any,
      );
    }

    // ── Prompts ──────────────────────────────────────────────────────
    for (const prompt of PROMPTS) {
      const hasArgs = prompt.arguments && prompt.arguments.length > 0;

      if (hasArgs) {
        const promptShape: z.ZodRawShape = {};
        for (const arg of prompt.arguments!) {
          promptShape[arg.name] = arg.required
            ? z.string().describe(arg.description ?? "")
            : z.string().optional().describe(arg.description ?? "");
        }
        this.server.prompt(
          prompt.name,
          prompt.description ?? "",
          promptShape,
          async (args: Record<string, string>) =>
            handleGetPrompt(
              prompt.name,
              args as Record<string, unknown>,
              this.mcpState,
            ) as any,
        );
      } else {
        this.server.prompt(
          prompt.name,
          prompt.description ?? "",
          async () =>
            handleGetPrompt(prompt.name, {}, this.mcpState) as any,
        );
      }
    }
  }
}

// ---------------------------------------------------------------------------
// Worker fetch handler
// ---------------------------------------------------------------------------

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext,
  ): Promise<Response> {
    const url = new URL(request.url);

    // Route MCP traffic to the Durable Object
    if (
      url.pathname === "/sse" ||
      url.pathname.startsWith("/sse/") ||
      url.pathname === "/mcp"
    ) {
      const id = env.MCP_OBJECT.idFromName("default");
      return env.MCP_OBJECT.get(id).fetch(request);
    }

    // CORS preflight
    if (request.method === "OPTIONS") {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type",
        },
      });
    }

    // Health / info
    return new Response(
      JSON.stringify({
        name: "solana-wallet-toolkit",
        version: "1.0.0",
        description: "Solana Wallet MCP Server — Cloudflare Workers",
        endpoints: {
          sse: "/sse",
          streamableHttp: "/mcp",
        },
      }),
      { headers: { "content-type": "application/json" } },
    );
  },
};
