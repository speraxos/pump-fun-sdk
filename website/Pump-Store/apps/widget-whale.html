<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="pump-include" content="pump.css">
    <meta name="capabilities" content="whale_alerts">
    <meta name="pump-icon" content="phishing">
    <meta name="pump-perms" content="network" />
    <title>Whale Alerts</title>
    <style>
        :root {
            --col-bg1: #101010;
            --col-bg2: #171717;
            --col-bg3: #222222;
            --col-txt1: white;
            --col-txt2: #aaa;
            --colors-accent: #00e87b;
            --col-good: #5be45b;
            --col-bad: #d44343;
            --col-warn: #f0a030;
            --siz-radius1: 0.5em;
            --siz-radius2: 0.375em;
            --font-size-small: 0.75em;
            --whale-blue: #4a9eff;
            --whale-purple: #a855f7;
            --whale-gold: #f5b041;
        }

        html { height: 100%; }

        body {
            margin: 0;
            height: 100%;
            background: var(--col-bg1);
            color: var(--col-txt1);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            overflow-y: auto;
        }

        * { box-sizing: border-box; }

        .app {
            max-width: 800px;
            margin: 0 auto;
            padding: 0.75em;
        }

        /* Header */
        .app-header {
            display: flex;
            align-items: center;
            gap: 0.5em;
            margin-bottom: 0.75em;
            flex-wrap: wrap;
        }
        .app-header h1 {
            font-size: 1.2em;
            margin: 0;
            font-weight: 700;
        }
        .header-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 0.75em;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--col-good);
            display: inline-block;
            box-shadow: 0 0 6px var(--col-good);
            transition: background 0.3s, box-shadow 0.3s;
        }
        .status-dot.error {
            background: var(--col-bad);
            box-shadow: 0 0 6px var(--col-bad);
        }
        .status-label {
            font-size: var(--font-size-small);
            color: var(--col-txt2);
        }
        .sound-toggle {
            background: var(--col-bg3);
            border: 1px solid #333;
            color: var(--col-txt1);
            border-radius: var(--siz-radius2);
            padding: 0.3em 0.55em;
            font-size: 0.85em;
            cursor: pointer;
            transition: background 0.15s;
            line-height: 1;
        }
        .sound-toggle:hover { background: var(--colors-accent); }
        .sound-toggle.muted { opacity: 0.5; }

        /* Filters */
        .filter-bar {
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 0.4em;
            padding: 0.55em 0;
            background: var(--col-bg1);
            border-bottom: 1px solid var(--col-bg3);
            margin-bottom: 0.6em;
            flex-wrap: wrap;
        }
        .filter-btn {
            background: var(--col-bg2);
            border: 1px solid #333;
            border-radius: var(--siz-radius2);
            color: var(--col-txt2);
            padding: 0.35em 0.7em;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.15s;
        }
        .filter-btn:hover { border-color: #555; color: var(--col-txt1); }
        .filter-btn.active {
            background: var(--colors-accent);
            border-color: var(--colors-accent);
            color: #fff;
        }
        .filter-stats {
            margin-left: auto;
            font-size: var(--font-size-small);
            color: var(--col-txt2);
        }

        /* Feed */
        .feed {
            display: flex;
            flex-direction: column;
            gap: 0.5em;
        }

        .alert-card {
            background: var(--col-bg2);
            border-radius: var(--siz-radius1);
            padding: 0.75em 0.85em;
            border-left: 3px solid var(--whale-blue);
            cursor: pointer;
            transition: background 0.15s, transform 0.15s;
            animation: slideIn 0.35s ease-out;
            display: flex;
            gap: 0.75em;
            align-items: flex-start;
        }
        .alert-card:hover {
            background: var(--col-bg3);
            transform: translateX(2px);
        }
        .alert-card.size-10m { border-left-color: var(--whale-purple); }
        .alert-card.size-100m { border-left-color: var(--whale-gold); }

        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .alert-icon {
            font-size: 1.5em;
            flex-shrink: 0;
            width: 1.5em;
            text-align: center;
            line-height: 1.3;
        }

        .alert-body {
            flex: 1;
            min-width: 0;
        }
        .alert-top {
            display: flex;
            align-items: baseline;
            gap: 0.5em;
            flex-wrap: wrap;
        }
        .alert-amount {
            font-size: 1.15em;
            font-weight: 700;
        }
        .alert-amount .coin {
            text-transform: uppercase;
            opacity: 0.8;
            font-size: 0.85em;
        }
        .alert-usd {
            font-size: 0.85em;
            color: var(--col-txt2);
        }
        .alert-card.size-10m .alert-amount { color: var(--whale-purple); }
        .alert-card.size-100m .alert-amount { color: var(--whale-gold); }

        .alert-route {
            margin-top: 0.35em;
            font-size: 0.82em;
            color: var(--col-txt2);
            display: flex;
            align-items: center;
            gap: 0.35em;
            flex-wrap: wrap;
        }
        .addr {
            font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', monospace;
            background: var(--col-bg3);
            padding: 0.1em 0.35em;
            border-radius: 3px;
            font-size: 0.9em;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block;
            vertical-align: bottom;
        }
        .addr.exchange { color: var(--colors-accent); }
        .arrow { color: #555; }

        .alert-time {
            font-size: var(--font-size-small);
            color: var(--col-txt2);
            margin-top: 0.3em;
            opacity: 0.7;
        }

        .alert-right {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.2em;
        }
        .coin-badge {
            font-size: 0.7em;
            font-weight: 600;
            text-transform: uppercase;
            padding: 0.2em 0.5em;
            border-radius: var(--siz-radius2);
            background: var(--col-bg3);
            color: var(--col-txt2);
            letter-spacing: 0.04em;
        }
        .coin-badge.btc { background: #3a2a10; color: #f7931a; }
        .coin-badge.eth { background: #1a2a3a; color: #627eea; }
        .coin-badge.usdt { background: #1a3a2a; color: #26a17b; }
        .coin-badge.usdc { background: #1a2a3a; color: #2775ca; }

        /* Loading */
        .loading {
            text-align: center;
            padding: 3em;
            color: var(--col-txt2);
        }
        .loading .spinner {
            display: inline-block;
            width: 28px;
            height: 28px;
            border: 3px solid var(--col-bg3);
            border-top-color: var(--colors-accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 0.5em;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Empty / Error */
        .empty-state {
            text-align: center;
            padding: 3em 1em;
            color: var(--col-txt2);
        }
        .empty-state .icon { font-size: 2.5em; margin-bottom: 0.3em; }
        .empty-state p { margin: 0.3em 0; }

        /* Total bar */
        .total-bar {
            display: flex;
            gap: 1em;
            padding: 0.6em 0.85em;
            background: var(--col-bg2);
            border-radius: var(--siz-radius1);
            margin-bottom: 0.6em;
            flex-wrap: wrap;
        }
        .total-item {
            display: flex;
            flex-direction: column;
        }
        .total-item .label {
            font-size: var(--font-size-small);
            color: var(--col-txt2);
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }
        .total-item .value {
            font-size: 1.1em;
            font-weight: 700;
        }
        .total-item .value.gold { color: var(--whale-gold); }
        .total-item .value.purple { color: var(--whale-purple); }

        /* Responsive */
        @media (max-width: 480px) {
            .alert-card { flex-direction: column; gap: 0.3em; }
            .alert-right { flex-direction: row; gap: 0.5em; }
            .addr { max-width: 90px; }
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="app-header">
            <h1>üêã Whale Alerts</h1>
            <div class="header-right">
                <span class="status-dot" id="statusDot"></span>
                <span class="status-label" id="statusLabel">Connecting‚Ä¶</span>
                <button class="sound-toggle" id="soundToggle" title="Toggle notification sound">üîî</button>
            </div>
        </div>

        <div class="total-bar" id="totalBar">
            <div class="total-item">
                <span class="label">Transactions</span>
                <span class="value" id="totalCount">0</span>
            </div>
            <div class="total-item">
                <span class="label">Total Volume</span>
                <span class="value gold" id="totalVolume">$0</span>
            </div>
            <div class="total-item">
                <span class="label">Largest</span>
                <span class="value purple" id="largestTx">‚Äî</span>
            </div>
        </div>

        <div class="filter-bar">
            <button class="filter-btn active" data-filter="all">All</button>
            <button class="filter-btn" data-filter="btc">BTC</button>
            <button class="filter-btn" data-filter="eth">ETH</button>
            <button class="filter-btn" data-filter="usdt">USDT</button>
            <button class="filter-btn" data-filter="usdc">USDC</button>
            <span class="filter-stats" id="filterStats">50 alerts</span>
        </div>

        <div class="feed" id="feed">
            <div class="loading"><div class="spinner"></div><br>Loading whale alerts‚Ä¶</div>
        </div>
    </div>

    <script>
    (function() {
        'use strict';
        const fetchFn = window.cfetch || fetch;

        // --- State ---
        const MAX_ITEMS = 50;
        let transactions = [];
        let activeFilter = 'all';
        let soundEnabled = true;
        let pollTimer = null;
        let isLive = false;

        // --- DOM refs ---
        const feed = document.getElementById('feed');
        const statusDot = document.getElementById('statusDot');
        const statusLabel = document.getElementById('statusLabel');
        const soundToggle = document.getElementById('soundToggle');
        const totalCount = document.getElementById('totalCount');
        const totalVolume = document.getElementById('totalVolume');
        const largestTx = document.getElementById('largestTx');
        const filterStats = document.getElementById('filterStats');

        // --- Audio (simple beep via AudioContext) ---
        let audioCtx = null;
        function playNotification() {
            if (!soundEnabled) return;
            try {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(440, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.3);
            } catch(e) { /* silent fail */ }
        }

        // --- Sound toggle ---
        soundToggle.addEventListener('click', function() {
            soundEnabled = !soundEnabled;
            soundToggle.textContent = soundEnabled ? 'üîî' : 'üîï';
            soundToggle.classList.toggle('muted', !soundEnabled);
        });

        // --- Status ---
        function setStatus(live, text) {
            isLive = live;
            statusDot.classList.toggle('error', !live);
            statusLabel.textContent = text || (live ? 'Live' : 'Error');
        }

        // --- Data helpers ---
        let cachedBtcUsdPrice = 97500;
        let cachedBtcUsdPriceAt = 0;

        const EXPLORER_URLS = {
            BTC: 'https://mempool.space/tx/',
            ETH: 'https://etherscan.io/tx/',
            USDT: 'https://etherscan.io/tx/',
            USDC: 'https://etherscan.io/tx/'
        };

        function makeStableId(prefix, value, fallback) {
            return [prefix, value || fallback || Date.now()].join('-');
        }

        async function getBtcUsdPrice() {
            const now = Date.now();
            if (cachedBtcUsdPriceAt > 0 && (now - cachedBtcUsdPriceAt) < 5 * 60 * 1000) {
                return cachedBtcUsdPrice;
            }

            try {
                const resp = await fetchFn('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
                if (!resp.ok) throw new Error('CoinGecko returned ' + resp.status);
                const data = await resp.json();
                const value = Number(data?.bitcoin?.usd);
                if (Number.isFinite(value) && value > 0) {
                    cachedBtcUsdPrice = value;
                    cachedBtcUsdPriceAt = now;
                }
            } catch (_) {
                // Keep previous cached value if pricing endpoint fails.
            }

            return cachedBtcUsdPrice;
        }

        // --- Whale Alert API attempt ---
        async function fetchWhaleAlertAPI() {
            const now = Math.floor(Date.now() / 1000);
            const start = now - 3600; // last hour
            const url = `https://api.whale-alert.io/v1/transactions?min_value=1000000&start=${start}`;
            const resp = await fetchFn(url);
            if (!resp.ok) throw new Error('API returned ' + resp.status);
            const data = await resp.json();
            if (data.result !== 'success' || !data.transactions) throw new Error('Bad response');
            return data.transactions.map((tx, index) => ({
                id: tx.id || makeStableId('wa', tx.hash, index),
                txHash: tx.hash || makeStableId('wa-hash', tx.id, index),
                coin: (tx.symbol || 'BTC').toUpperCase(),
                amount: tx.amount || 0,
                usdValue: tx.amount_usd || 0,
                from: {
                    name: (tx.from && tx.from.owner) || 'Unknown Wallet',
                    type: (tx.from && tx.from.owner_type) || 'unknown',
                    address: (tx.from && tx.from.address) || ''
                },
                to: {
                    name: (tx.to && tx.to.owner) || 'Unknown Wallet',
                    type: (tx.to && tx.to.owner_type) || 'unknown',
                    address: (tx.to && tx.to.address) || ''
                },
                timestamp: (tx.timestamp || now) * 1000
            }));
        }

        // --- Blockchair BTC fallback ---
        async function fetchBlockchairFallback() {
            const url = 'https://api.blockchair.com/bitcoin/transactions?q=output_total(100000000..)&limit=10&s=time(desc)';
            const resp = await fetchFn(url);
            if (!resp.ok) throw new Error('Blockchair returned ' + resp.status);
            const data = await resp.json();
            if (!data.data || !data.data.length) throw new Error('No data');
            const btcUsdPrice = await getBtcUsdPrice();
            return data.data.map(tx => {
                const satoshis = tx.output_total || 0;
                const btcAmount = satoshis / 1e8;
                const usd = btcAmount * btcUsdPrice;
                return {
                    id: tx.hash || makeStableId('bc', tx.time, tx.id),
                    txHash: tx.hash || makeStableId('bc-hash', tx.time, tx.id),
                    coin: 'BTC',
                    amount: btcAmount,
                    usdValue: usd,
                    from: { name: 'Unknown Wallet', type: 'unknown', address: '' },
                    to: { name: 'Unknown Wallet', type: 'unknown', address: '' },
                    timestamp: tx.time ? new Date(tx.time).getTime() : Date.now()
                };
            });
        }

        // --- Data fetch with cascade (real sources only) ---

        async function fetchData(initial) {
            // Try Whale Alert ‚Üí Blockchair
            const errors = [];
            try {
                const data = await fetchWhaleAlertAPI();
                if (data.length > 0) {
                    setStatus(true, 'Live (Whale Alert)');
                    return data;
                }
                errors.push('Whale Alert: no data');
            } catch(e) {
                errors.push('Whale Alert: ' + (e && e.message ? e.message : 'failed'));
            }

            try {
                const data = await fetchBlockchairFallback();
                if (data.length > 0) {
                    setStatus(true, 'Live (Blockchair)');
                    return data;
                }
                errors.push('Blockchair: no data');
            } catch(e) {
                errors.push('Blockchair: ' + (e && e.message ? e.message : 'failed'));
            }

            setStatus(false, 'Data source unavailable');
            throw new Error(errors.join(' | '));
        }

        // --- Format helpers ---
        function formatAmount(num, coin) {
            if (coin === 'USDT' || coin === 'USDC') {
                return num >= 1e6
                    ? (num / 1e6).toFixed(1) + 'M'
                    : Math.round(num).toLocaleString();
            }
            if (num >= 10000) return Math.round(num).toLocaleString();
            if (num >= 100) return num.toFixed(1);
            return num.toFixed(4);
        }

        function formatUSD(num) {
            if (num >= 1e9) return '$' + (num / 1e9).toFixed(2) + 'B';
            if (num >= 1e6) return '$' + (num / 1e6).toFixed(1) + 'M';
            if (num >= 1e3) return '$' + (num / 1e3).toFixed(0) + 'K';
            return '$' + Math.round(num).toLocaleString();
        }

        function timeAgo(ts) {
            const diff = Math.max(0, Math.floor((Date.now() - ts) / 1000));
            if (diff < 60) return diff + 's ago';
            if (diff < 3600) return Math.floor(diff / 60) + 'm ago';
            if (diff < 86400) return Math.floor(diff / 3600) + 'h ago';
            return Math.floor(diff / 86400) + 'd ago';
        }

        function truncAddr(addr) {
            if (!addr || addr.length < 14) return addr || '???';
            return addr.slice(0, 6) + '‚Ä¶' + addr.slice(-4);
        }

        function getTxIcon(from, to) {
            if (from.type === 'exchange' && to.type === 'exchange') return 'üîÑ';
            if (from.type === 'unknown' && to.type === 'exchange') return 'üì•';
            if (from.type === 'exchange' && to.type === 'unknown') return 'üì§';
            return 'üí∞';
        }

        function getSizeClass(usdValue) {
            if (usdValue >= 100e6) return 'size-100m';
            if (usdValue >= 10e6) return 'size-10m';
            return '';
        }

        function getExplorerUrl(tx) {
            const base = EXPLORER_URLS[tx.coin] || EXPLORER_URLS.BTC;
            return base + tx.txHash;
        }

        // --- Render ---
        function renderCard(tx) {
            const sizeClass = getSizeClass(tx.usdValue);
            const icon = getTxIcon(tx.from, tx.to);
            const coinLower = tx.coin.toLowerCase();
            const badgeClass = ['btc','eth','usdt','usdc'].includes(coinLower) ? coinLower : '';

            const fromLabel = tx.from.type === 'exchange' ? tx.from.name : truncAddr(tx.from.address);
            const toLabel = tx.to.type === 'exchange' ? tx.to.name : truncAddr(tx.to.address);
            const fromClass = tx.from.type === 'exchange' ? 'addr exchange' : 'addr';
            const toClass = tx.to.type === 'exchange' ? 'addr exchange' : 'addr';

            const card = document.createElement('div');
            card.className = 'alert-card ' + sizeClass;
            card.dataset.coin = coinLower;
            card.dataset.id = tx.id;
            card.title = 'Click to view on explorer';

            card.innerHTML =
                '<div class="alert-icon">' + icon + '</div>' +
                '<div class="alert-body">' +
                    '<div class="alert-top">' +
                        '<span class="alert-amount">' + formatAmount(tx.amount, tx.coin) + ' <span class="coin">' + tx.coin + '</span></span>' +
                        '<span class="alert-usd">' + formatUSD(tx.usdValue) + '</span>' +
                    '</div>' +
                    '<div class="alert-route">' +
                        '<span class="' + fromClass + '">' + fromLabel + '</span>' +
                        '<span class="arrow">‚Üí</span>' +
                        '<span class="' + toClass + '">' + toLabel + '</span>' +
                    '</div>' +
                    '<div class="alert-time">' + timeAgo(tx.timestamp) + '</div>' +
                '</div>' +
                '<div class="alert-right">' +
                    '<span class="coin-badge ' + badgeClass + '">' + tx.coin + '</span>' +
                '</div>';

            card.addEventListener('click', function() {
                window.open(getExplorerUrl(tx), '_blank');
            });

            return card;
        }

        function renderFeed() {
            const filtered = activeFilter === 'all'
                ? transactions
                : transactions.filter(tx => tx.coin.toLowerCase() === activeFilter);

            filterStats.textContent = filtered.length + ' alert' + (filtered.length !== 1 ? 's' : '');

            feed.innerHTML = '';
            if (filtered.length === 0) {
                feed.innerHTML = '<div class="empty-state"><div class="icon">üêã</div><p>No whale alerts found</p><p style="font-size:0.85em;opacity:0.6;">Waiting for large transactions‚Ä¶</p></div>';
                return;
            }

            filtered.forEach(function(tx) {
                feed.appendChild(renderCard(tx));
            });
        }

        function renderErrorState() {
            feed.innerHTML = '' +
                '<div class="empty-state">' +
                    '<div class="icon">‚ö†Ô∏è</div>' +
                    '<p>Unable to fetch whale data.</p>' +
                    '<p style="font-size:0.85em;opacity:0.75;">APIs may be rate-limited ‚Äî try again in 60 seconds.</p>' +
                    '<button id="retryWhaleBtn" class="sound-toggle" style="margin-top:12px;">Retry now</button>' +
                '</div>';
            const retryBtn = document.getElementById('retryWhaleBtn');
            if (retryBtn) {
                retryBtn.addEventListener('click', async function() {
                    retryBtn.disabled = true;
                    retryBtn.textContent = 'Retrying‚Ä¶';
                    try {
                        const data = await fetchData(false);
                        transactions = data.slice(0, MAX_ITEMS).sort(function(a, b) { return b.timestamp - a.timestamp; });
                        renderFeed();
                        updateTotals();
                    } catch (_) {
                        renderErrorState();
                    }
                });
            }
        }

        function updateTotals() {
            totalCount.textContent = transactions.length;
            const vol = transactions.reduce(function(s, tx) { return s + tx.usdValue; }, 0);
            totalVolume.textContent = formatUSD(vol);
            if (transactions.length > 0) {
                const max = transactions.reduce(function(m, tx) { return tx.usdValue > m.usdValue ? tx : m; }, transactions[0]);
                largestTx.textContent = formatUSD(max.usdValue) + ' ' + max.coin;
            } else {
                largestTx.textContent = '‚Äî';
            }
        }

        // --- Update time labels periodically ---
        function refreshTimes() {
            const cards = feed.querySelectorAll('.alert-card');
            cards.forEach(function(card) {
                const id = card.dataset.id;
                const tx = transactions.find(function(t) { return t.id === id; });
                if (tx) {
                    const timeEl = card.querySelector('.alert-time');
                    if (timeEl) timeEl.textContent = timeAgo(tx.timestamp);
                }
            });
        }

        // --- Filters ---
        document.querySelectorAll('.filter-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.filter-btn').forEach(function(b) { b.classList.remove('active'); });
                btn.classList.add('active');
                activeFilter = btn.dataset.filter;
                renderFeed();
            });
        });

        // --- Polling ---
        async function poll() {
            try {
                const newData = await fetchData(false);
                if (newData && newData.length > 0) {
                    // Deduplicate
                    const existingIds = new Set(transactions.map(function(t) { return t.id; }));
                    const fresh = newData.filter(function(tx) { return !existingIds.has(tx.id); });

                    if (fresh.length > 0) {
                        transactions = fresh.concat(transactions).slice(0, MAX_ITEMS);
                        transactions.sort(function(a, b) { return b.timestamp - a.timestamp; });
                        playNotification();
                        renderFeed();
                        updateTotals();
                    }
                    if (!isLive) setStatus(true, 'Live');
                }
            } catch(e) {
                setStatus(false, 'Connection error');
                if (!transactions.length) {
                    renderErrorState();
                }
            }
        }

        // --- Init ---
        async function init() {
            try {
                const data = await fetchData(true);
                transactions = data.slice(0, MAX_ITEMS);
                transactions.sort(function(a, b) { return b.timestamp - a.timestamp; });
                if (!isLive) setStatus(true, 'Live');
                renderFeed();
                updateTotals();
            } catch(e) {
                setStatus(false, 'Failed to load');
                renderErrorState();
            }

            // Poll every 30s
            pollTimer = setInterval(poll, 30000);
            // Refresh timestamps every 15s
            setInterval(refreshTimes, 15000);
        }

        init();
    })();
    </script>
</body>
</html>