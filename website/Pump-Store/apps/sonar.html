<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="lair-include" content="lair.css material-symbols-rounded">
    <meta name="lair-icon" content='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" stroke="#34d4f1" stroke-width=".5" opacity=".3"/><circle cx="12" cy="12" r="7" stroke="#34d4f1" stroke-width=".4" opacity=".25"/><circle cx="12" cy="12" r="4" stroke="#34d4f1" stroke-width=".3" opacity=".2"/><line x1="12" y1="2" x2="12" y2="22" stroke="#34d4f1" stroke-width=".2" opacity=".15"/><line x1="2" y1="12" x2="22" y2="12" stroke="#34d4f1" stroke-width=".2" opacity=".15"/><line x1="12" y1="12" x2="20" y2="6" stroke="#34d4f1" stroke-width="1.2" opacity=".7"/><circle cx="17" cy="8" r="1.5" fill="#34d4f1" opacity=".6"/><circle cx="9" cy="7" r="1" fill="#00e87b" opacity=".5"/><circle cx="15" cy="15" r="1.2" fill="#fbbf24" opacity=".5"/></svg>'>
    <meta name="permissions" content="network">
    <meta name="capabilities" content="crypto_anomaly_radar_scanner">
    <meta name="lair-category" content="analytics">
    <meta name="lair-perms" content="network" />
    <title>Lair Sonar</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #010810;
            color: #34d4f1;
            font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', monospace;
            user-select: none;
        }

        /* ─── Layout ─── */
        .sonar-layout {
            display: grid;
            grid-template-columns: 1fr 300px;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
        }

        /* ─── Header ─── */
        .sonar-header {
            grid-column: 1 / -1;
            display: flex; align-items: center; justify-content: space-between;
            padding: 8px 16px;
            background: rgba(0,15,30,0.8);
            border-bottom: 1px solid rgba(52,212,241,0.08);
        }
        .sh-title {
            font-size: 11px; letter-spacing: 0.4em;
            text-transform: uppercase; opacity: 0.5; font-weight: 600;
        }
        .sh-status {
            display: flex; gap: 12px; align-items: center;
            font-size: 10px; opacity: 0.4; letter-spacing: 0.08em;
        }
        .sh-dot {
            width: 6px; height: 6px; border-radius: 50%;
            background: #34d4f1; animation: blink 2s ease-in-out infinite;
        }
        @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }
        .sh-clock { font-variant-numeric: tabular-nums; }

        /* ─── Radar Canvas ─── */
        .radar-wrap {
            position: relative;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,8,16,0.6);
            overflow: hidden;
        }
        canvas#radar {
            max-width: 100%; max-height: 100%;
        }

        /* ─── Signal Log (right panel) ─── */
        .signal-panel {
            background: rgba(0,12,24,0.7);
            border-left: 1px solid rgba(52,212,241,0.06);
            display: flex; flex-direction: column;
            overflow: hidden;
        }
        .sp-header {
            padding: 12px 14px 8px;
            font-size: 9px; letter-spacing: 0.2em;
            text-transform: uppercase; opacity: 0.35;
            border-bottom: 1px solid rgba(52,212,241,0.06);
            display: flex; justify-content: space-between; align-items: center;
        }
        .sp-count {
            background: rgba(52,212,241,0.1);
            border: 1px solid rgba(52,212,241,0.2);
            border-radius: 10px; padding: 1px 8px;
            font-size: 10px; font-weight: 600; opacity: 0.7;
        }
        .sp-list {
            flex: 1; overflow-y: auto; padding: 6px 0;
            scrollbar-width: thin;
            scrollbar-color: rgba(52,212,241,0.15) transparent;
        }
        .sp-item {
            padding: 8px 14px;
            border-bottom: 1px solid rgba(52,212,241,0.03);
            cursor: pointer;
            transition: background 0.15s;
        }
        .sp-item:hover { background: rgba(52,212,241,0.05); }
        .sp-item-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 3px;
        }
        .sp-item-symbol { font-size: 12px; font-weight: 700; }
        .sp-item-type {
            font-size: 8px; letter-spacing: 0.1em;
            text-transform: uppercase; padding: 2px 6px;
            border-radius: 4px; font-weight: 600;
        }
        .sp-item-type.volume { background: rgba(52,212,241,0.12); color: #34d4f1; }
        .sp-item-type.breakout { background: rgba(0,232,123,0.12); color: #00e87b; }
        .sp-item-type.crash { background: rgba(255,107,107,0.12); color: #ff6b6b; }
        .sp-item-type.whale { background: rgba(251,191,36,0.12); color: #fbbf24; }
        .sp-item-type.divergence { background: rgba(192,132,252,0.12); color: #c084fc; }
        .sp-item-detail {
            font-size: 10px; opacity: 0.4; line-height: 1.4;
        }
        .sp-item-time {
            font-size: 9px; opacity: 0.25; margin-top: 3px;
        }

        /* ─── Sector Legend (bottom left of radar) ─── */
        .sector-legend {
            position: absolute; bottom: 10px; left: 10px;
            font-size: 8px; opacity: 0.25; line-height: 1.8;
            z-index: 5; pointer-events: none;
        }
        .sector-legend span { margin-right: 2px; }

        /* ─── Tooltip ─── */
        #tooltip {
            position: fixed; z-index: 30;
            display: none; pointer-events: none;
            min-width: 180px; max-width: 260px;
            background: rgba(0,12,24,0.95);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(52,212,241,0.12);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            font-size: 11px;
        }
        .tt-name { font-weight: 700; font-size: 13px; margin-bottom: 6px; }
        .tt-row { display: flex; justify-content: space-between; padding: 2px 0; }
        .tt-label { opacity: 0.4; }
        .tt-value { font-weight: 600; font-variant-numeric: tabular-nums; }
        .tt-signal {
            margin-top: 8px; padding-top: 6px;
            border-top: 1px solid rgba(52,212,241,0.08);
            font-size: 10px; opacity: 0.5;
        }

        /* ─── Footer ─── */
        .sonar-footer {
            grid-column: 1 / -1;
            display: flex; align-items: center; justify-content: space-between;
            padding: 6px 16px;
            background: rgba(0,15,30,0.8);
            border-top: 1px solid rgba(52,212,241,0.08);
        }
        .sf-controls {
            display: flex; gap: 6px;
        }
        .sf-btn {
            background: rgba(52,212,241,0.04);
            border: 1px solid rgba(52,212,241,0.1);
            color: rgba(52,212,241,0.5);
            border-radius: 6px; padding: 4px 10px;
            font-size: 9px; cursor: pointer;
            letter-spacing: 0.05em; font-family: inherit;
            transition: all 0.2s;
            display: flex; align-items: center; gap: 4px;
        }
        .sf-btn:hover { background: rgba(52,212,241,0.08); color: rgba(52,212,241,0.8); }
        .sf-btn.active { background: rgba(52,212,241,0.12); border-color: rgba(52,212,241,0.3); color: #34d4f1; }
        .sf-btn .material-symbols-rounded { font-size: 13px; }
        .sf-stats {
            font-size: 9px; opacity: 0.3; letter-spacing: 0.08em;
            display: flex; gap: 16px;
            font-variant-numeric: tabular-nums;
        }

        /* ─── Loading ─── */
        #loader {
            position: fixed; inset: 0; z-index: 50;
            background: #010810;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            gap: 20px; transition: opacity 0.8s ease;
        }
        #loader.fade { opacity: 0; pointer-events: none; }
        .loader-sweep {
            width: 60px; height: 60px; position: relative;
        }
        .loader-sweep::before {
            content: ''; position: absolute; inset: 0;
            border: 1px solid rgba(52,212,241,0.2);
            border-radius: 50%;
        }
        .loader-sweep::after {
            content: ''; position: absolute;
            top: 50%; left: 50%; width: 50%; height: 1px;
            background: linear-gradient(90deg, rgba(52,212,241,0.8), transparent);
            transform-origin: left center;
            animation: sweep 2s linear infinite;
        }
        @keyframes sweep { to { transform: rotate(360deg); } }
        .loader-text {
            font-size: 10px; letter-spacing: 0.4em;
            text-transform: uppercase; opacity: 0.3;
        }

        /* ─── Responsive ─── */
        @media (max-width: 700px) {
            .sonar-layout { grid-template-columns: 1fr; }
            .signal-panel { display: none; }
        }
    </style>
</head>
<body>

<div class="sonar-layout">
    <div class="sonar-header">
        <div class="sh-status">
            <div class="sh-dot"></div>
            <span>Scanning</span>
        </div>
        <div class="sh-title">Lair Sonar</div>
        <div class="sh-status">
            <span class="sh-clock" id="clock">--:--:--</span>
        </div>
    </div>

    <div class="radar-wrap">
        <canvas id="radar"></canvas>
        <div class="sector-legend" id="sector-legend"></div>
    </div>

    <div class="signal-panel">
        <div class="sp-header">
            <span>Signal Log</span>
            <span class="sp-count" id="signal-count">0</span>
        </div>
        <div class="sp-list" id="signal-list"></div>
    </div>

    <div class="sonar-footer">
        <div class="sf-controls">
            <button class="sf-btn active" id="btn-sweep" title="Toggle sweep">
                <span class="material-symbols-rounded">radar</span> Sweep
            </button>
            <button class="sf-btn" id="btn-audio" title="Toggle audio">
                <span class="material-symbols-rounded">volume_off</span>
            </button>
            <button class="sf-btn active" id="btn-labels" title="Toggle labels">
                <span class="material-symbols-rounded">label</span>
            </button>
            <button class="sf-btn" id="btn-filter" title="Cycle filter">
                <span class="material-symbols-rounded">filter_alt</span> All
            </button>
        </div>
        <div class="sf-stats">
            <span id="stat-tokens">— tokens</span>
            <span id="stat-signals">— signals</span>
            <span id="stat-sweep">sweep 0°</span>
        </div>
    </div>
</div>

<!-- Tooltip -->
<div id="tooltip">
    <div class="tt-name" id="tt-name"></div>
    <div class="tt-row"><span class="tt-label">Price</span><span class="tt-value" id="tt-price"></span></div>
    <div class="tt-row"><span class="tt-label">24h</span><span class="tt-value" id="tt-change"></span></div>
    <div class="tt-row"><span class="tt-label">Volume</span><span class="tt-value" id="tt-vol"></span></div>
    <div class="tt-row"><span class="tt-label">MCap</span><span class="tt-value" id="tt-mcap"></span></div>
    <div class="tt-signal" id="tt-signal"></div>
</div>

<!-- Loader -->
<div id="loader">
    <div class="loader-sweep"></div>
    <div class="loader-text">Initializing sonar</div>
</div>

<script>
'use strict';

// ─── Canvas ──────────────────────────────────────────────────────────────────
const canvas = document.getElementById('radar');
const ctx = canvas.getContext('2d');
let SIZE, CX, CY, RADIUS;

function resize() {
    const wrap = canvas.parentElement;
    const s = Math.min(wrap.clientWidth, wrap.clientHeight) - 20;
    SIZE = s;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = s * dpr;
    canvas.height = s * dpr;
    canvas.style.width = s + 'px';
    canvas.style.height = s + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    CX = s / 2;
    CY = s / 2;
    RADIUS = s / 2 - 15;
}
resize();
window.addEventListener('resize', resize);

// ─── State ───────────────────────────────────────────────────────────────────
let tokens = [];        // All fetched tokens
let blips = [];         // Radar blips (positioned tokens)
let signals = [];       // Detected anomalies
let sweepAngle = 0;     // Current sweep angle in radians
let sweepRunning = true;
let audioOn = false;
let showLabels = true;
let filterMode = 'all'; // all, volume, breakout, crash, whale
const FILTER_MODES = ['all', 'volume', 'breakout', 'crash'];
let lastFetch = 0;
const FETCH_INTERVAL = 90_000;
let hoveredBlip = null;
let mouseX = null, mouseY = null;

// Sector definitions (angle ranges on the radar)
const SECTORS = [
    { name: 'L1/L2',       angle: 0,      span: 45,  color: '#00e87b', ids: ['bitcoin','ethereum','solana','cardano','avalanche-2','polkadot','near','sui','aptos','toncoin','tron','cosmos','algorand','fantom','matic-network','arbitrum','optimism','starknet'] },
    { name: 'DeFi',        angle: 45,     span: 45,  color: '#00e87b', ids: ['uniswap','aave','lido-dao','maker','compound-governance-token','curve-dao-token','pancakeswap-token','jupiter-exchange-solana','raydium','sushi','1inch','synthetix-network-token'] },
    { name: 'Stablecoins', angle: 90,     span: 30,  color: '#ffd700', ids: ['tether','usd-coin','dai','first-digital-usd','true-usd','ethena-usde','frax'] },
    { name: 'Meme',        angle: 120,    span: 45,  color: '#ff6b9d', ids: ['dogecoin','shiba-inu','pepe','bonk','floki','dogwifcoin','brett','popcat','mog-coin','turbo'] },
    { name: 'AI',          angle: 165,    span: 40,  color: '#22d3ee', ids: ['fetch-ai','render-token','the-graph','ocean-protocol','singularitynet','bittensor','worldcoin-wld','akash-network','io-net'] },
    { name: 'Gaming',      angle: 205,    span: 35,  color: '#f97316', ids: ['immutable-x','axie-infinity','the-sandbox','gala','illuvium','pixels','beam-2','ronin'] },
    { name: 'Exchange',    angle: 240,    span: 35,  color: '#fbbf24', ids: ['binancecoin','okb','crypto-com-chain','leo-token','kucoin-shares','mx-token','gate-token'] },
    { name: 'Infra',       angle: 275,    span: 45,  color: '#a78bfa', ids: ['chainlink','filecoin','internet-computer','hedera-hashgraph','vechain','theta-token','arweave','helium','pyth-network'] },
    { name: 'Privacy',     angle: 320,    span: 40,  color: '#64748b', ids: ['monero','zcash','dash','secret','oasis-network'] },
];

// ─── Fetch data ──────────────────────────────────────────────────────────────
const _f = window.cfetch || fetch;
async function fetchData() {
    try {
        // Fetch top 250 tokens across 3 pages
        const pages = [1, 2, 3];
        const results = await Promise.allSettled(
            pages.map(p =>
                _f(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=${p}&sparkline=false&price_change_percentage=1h,24h,7d`)
                    .then(r => r.ok ? r.json() : [])
            )
        );

        const allTokens = results
            .filter(r => r.status === 'fulfilled')
            .flatMap(r => r.value)
            .filter(t => t && t.id);

        if (allTokens.length > 0) {
            tokens = allTokens;
            positionBlips();
            detectSignals();
            lastFetch = Date.now();
        }

        // Update stats
        document.getElementById('stat-tokens').textContent = tokens.length + ' tokens';

        // Hide loader
        const loader = document.getElementById('loader');
        if (loader && !loader.classList.contains('fade')) {
            loader.classList.add('fade');
            setTimeout(() => loader.remove(), 800);
        }
    } catch (e) {
        console.error('Fetch error:', e);
        setTimeout(fetchData, 10_000);
    }
}

// ─── Position blips on radar ─────────────────────────────────────────────────
function positionBlips() {
    blips = [];
    const maxMcap = Math.max(...tokens.map(t => t.market_cap || 0), 1);

    tokens.forEach(token => {
        // Find sector
        let sector = null;
        for (const s of SECTORS) {
            if (s.ids.includes(token.id)) { sector = s; break; }
        }
        // Unmatched tokens go to a "catch-all" zone based on mcap rank
        if (!sector) {
            const rank = tokens.indexOf(token);
            const sectorIdx = rank % SECTORS.length;
            sector = SECTORS[sectorIdx];
        }

        // Angle: within sector's angular span, spread evenly + jitter
        const sectorTokens = tokens.filter(t => {
            for (const s of SECTORS) {
                if (s === sector && s.ids.includes(t.id)) return true;
            }
            return false;
        });
        const idxInSector = sectorTokens.indexOf(token);
        const baseAngle = (sector.angle + sector.span * 0.1 + (sector.span * 0.8) * Math.random()) * (Math.PI / 180);

        // Distance from center: inversely proportional to market cap (bigger = closer to center)
        const mcapNorm = Math.log10(token.market_cap || 1) / Math.log10(maxMcap || 1);
        const dist = RADIUS * (0.15 + (1 - mcapNorm) * 0.8);

        // Signal strength (for visual prominence)
        const change = token.price_change_percentage_24h || 0;
        const volRatio = (token.total_volume || 0) / (token.market_cap || 1);
        const signalStrength = Math.min(1, (Math.abs(change) / 15 + volRatio * 5) / 2);

        blips.push({
            token,
            angle: baseAngle,
            dist,
            x: CX + Math.cos(baseAngle) * dist,
            y: CY + Math.sin(baseAngle) * dist,
            radius: 2 + signalStrength * 5,
            color: sector.color,
            sectorName: sector.name,
            signalStrength,
            change,
            fadeAge: 0,     // Fades after sweep passes
            pingTime: 0,    // When sweep last hit this blip
            hasSignal: false,
            signalType: null,
        });
    });

    // Recalculate positions for current canvas size
    recalcPositions();
}

function recalcPositions() {
    blips.forEach(b => {
        b.x = CX + Math.cos(b.angle) * b.dist;
        b.y = CY + Math.sin(b.angle) * b.dist;
    });
}
window.addEventListener('resize', () => { resize(); recalcPositions(); });

// ─── Anomaly detection ───────────────────────────────────────────────────────
function detectSignals() {
    const newSignals = [];

    tokens.forEach(token => {
        const change = token.price_change_percentage_24h || 0;
        const change1h = token.price_change_percentage_1h_in_currency || 0;
        const volRatio = (token.total_volume || 0) / (token.market_cap || 1);
        const symbol = (token.symbol || '').toUpperCase();

        // Volume spike: vol/mcap > 15%
        if (volRatio > 0.15) {
            newSignals.push({
                token, type: 'volume',
                message: `Unusual volume — ${(volRatio * 100).toFixed(1)}% of market cap`,
                strength: Math.min(1, volRatio / 0.3),
                time: Date.now(),
            });
        }

        // Breakout: >8% in 24h
        if (change > 8) {
            newSignals.push({
                token, type: 'breakout',
                message: `Rally detected — ${change.toFixed(1)}% in 24h`,
                strength: Math.min(1, change / 25),
                time: Date.now(),
            });
        }

        // Crash: <-8% in 24h
        if (change < -8) {
            newSignals.push({
                token, type: 'crash',
                message: `Dump detected — ${change.toFixed(1)}% in 24h`,
                strength: Math.min(1, Math.abs(change) / 25),
                time: Date.now(),
            });
        }

        // Whale activity: high volume + moderate change (accumulation/distribution)
        if (volRatio > 0.08 && Math.abs(change) < 3) {
            newSignals.push({
                token, type: 'whale',
                message: `Stealth accumulation — high vol, low change`,
                strength: Math.min(1, volRatio / 0.15),
                time: Date.now(),
            });
        }
    });

    // Sort by strength
    newSignals.sort((a, b) => b.strength - a.strength);
    signals = newSignals.slice(0, 50);

    // Mark blips that have signals
    blips.forEach(b => {
        const sig = signals.find(s => s.token.id === b.token.id);
        if (sig) {
            b.hasSignal = true;
            b.signalType = sig.type;
        }
    });

    // Update signal log
    renderSignalLog();
    document.getElementById('stat-signals').textContent = signals.length + ' signals';
    document.getElementById('signal-count').textContent = signals.length;
}

function renderSignalLog() {
    const list = document.getElementById('signal-list');
    const filtered = filterMode === 'all' ? signals : signals.filter(s => s.type === filterMode);

    list.innerHTML = filtered.map(s => {
        const sym = (s.token.symbol || '').toUpperCase();
        const change = s.token.price_change_percentage_24h || 0;
        const timeStr = new Date(s.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

        return `<div class="sp-item" data-id="${s.token.id}">
            <div class="sp-item-header">
                <span class="sp-item-symbol">${sym}</span>
                <span class="sp-item-type ${s.type}">${s.type}</span>
            </div>
            <div class="sp-item-detail">${s.message}</div>
            <div class="sp-item-time">${timeStr} · $${fmtPrice(s.token.current_price)} · ${change >= 0 ? '+' : ''}${change.toFixed(1)}%</div>
        </div>`;
    }).join('');

    // Click to highlight
    list.querySelectorAll('.sp-item').forEach(el => {
        el.addEventListener('click', () => {
            const id = el.dataset.id;
            const blip = blips.find(b => b.token.id === id);
            if (blip) {
                blip.pingTime = Date.now();
                blip.fadeAge = 0;
            }
        });
    });
}

// ─── Audio ───────────────────────────────────────────────────────────────────
let audioCtx = null;
let masterGain = null;

function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.12;
    masterGain.connect(audioCtx.destination);
}

function playPing(strength, type) {
    if (!audioCtx || !audioOn) return;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();

    // Different sounds for different signal types
    let freq, wave;
    switch (type) {
        case 'breakout': freq = 880 + strength * 200; wave = 'sine'; break;
        case 'crash':    freq = 220 + strength * 100; wave = 'sawtooth'; break;
        case 'volume':   freq = 440 + strength * 150; wave = 'triangle'; break;
        case 'whale':    freq = 330; wave = 'sine'; break;
        default:         freq = 660; wave = 'sine';
    }

    osc.type = wave;
    osc.frequency.value = freq;
    filter.type = 'lowpass';
    filter.frequency.value = 2000;
    filter.Q.value = 2;

    gain.gain.setValueAtTime(0.06 + strength * 0.06, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(masterGain);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.5);
}

// Classic sonar ping
function playSonarPing() {
    if (!audioCtx || !audioOn) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.15);

    gain.gain.setValueAtTime(0.03, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);

    osc.connect(gain);
    gain.connect(masterGain);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.8);
}

// ─── Render ──────────────────────────────────────────────────────────────────
let lastSonarPing = 0;

function render() {
    requestAnimationFrame(render);
    const now = Date.now();

    // ── Update sweep angle
    if (sweepRunning) {
        sweepAngle += 0.012; // ~3.4s per revolution
        if (sweepAngle >= Math.PI * 2) {
            sweepAngle -= Math.PI * 2;
            // Sonar ping at each full revolution
            if (now - lastSonarPing > 3000) {
                playSonarPing();
                lastSonarPing = now;
            }
        }
    }

    // ── Clock
    document.getElementById('clock').textContent = new Date().toLocaleTimeString([], {
        hour: '2-digit', minute: '2-digit', second: '2-digit',
    });
    document.getElementById('stat-sweep').textContent = 'sweep ' + Math.round(sweepAngle * 180 / Math.PI) + '°';

    ctx.clearRect(0, 0, SIZE, SIZE);

    // ── Background
    const bgGrad = ctx.createRadialGradient(CX, CY, 0, CX, CY, RADIUS * 1.2);
    bgGrad.addColorStop(0, '#020e18');
    bgGrad.addColorStop(0.7, '#010a12');
    bgGrad.addColorStop(1, '#010810');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, SIZE, SIZE);

    // ── Grid rings
    for (let i = 1; i <= 4; i++) {
        const r = RADIUS * (i / 4);
        ctx.beginPath();
        ctx.arc(CX, CY, r, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(52,212,241,${i === 4 ? 0.12 : 0.05})`;
        ctx.lineWidth = i === 4 ? 1.5 : 0.5;
        ctx.stroke();
    }

    // ── Cross lines
    ctx.strokeStyle = 'rgba(52,212,241,0.04)';
    ctx.lineWidth = 0.5;
    for (let a = 0; a < Math.PI * 2; a += Math.PI / 6) {
        ctx.beginPath();
        ctx.moveTo(CX, CY);
        ctx.lineTo(CX + Math.cos(a) * RADIUS, CY + Math.sin(a) * RADIUS);
        ctx.stroke();
    }

    // ── Sector labels on outer ring
    SECTORS.forEach(s => {
        const midAngle = (s.angle + s.span / 2) * Math.PI / 180;
        const lx = CX + Math.cos(midAngle) * (RADIUS + 10);
        const ly = CY + Math.sin(midAngle) * (RADIUS + 10);
        ctx.font = '8px monospace';
        ctx.fillStyle = `rgba(52,212,241,0.2)`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // Don't draw if too close to edge
        if (lx > 20 && lx < SIZE - 20 && ly > 10 && ly < SIZE - 10) {
            ctx.fillText(s.name, lx, ly);
        }

        // Sector boundary lines
        const startAngle = s.angle * Math.PI / 180;
        ctx.beginPath();
        ctx.moveTo(CX, CY);
        ctx.lineTo(CX + Math.cos(startAngle) * RADIUS, CY + Math.sin(startAngle) * RADIUS);
        ctx.strokeStyle = `rgba(52,212,241,0.03)`;
        ctx.lineWidth = 0.5;
        ctx.stroke();
    });

    // ── Sweep beam
    if (sweepRunning) {
        const sweepGrad = ctx.createConicalGradient
            ? null // Not all browsers support this
            : null;

        // Draw sweep trail (fading arc behind the sweep line)
        const trailAngle = 0.6; // ~35 degrees of trail
        ctx.beginPath();
        ctx.moveTo(CX, CY);
        ctx.arc(CX, CY, RADIUS, sweepAngle - trailAngle, sweepAngle);
        ctx.closePath();

        const sweepFill = ctx.createConicGradient
            ? (() => {
                // Use conic gradient if available
                const g = ctx.createConicGradient(sweepAngle - trailAngle, CX, CY);
                g.addColorStop(0, 'rgba(52,212,241,0)');
                g.addColorStop(0.95, 'rgba(52,212,241,0.08)');
                g.addColorStop(1, 'rgba(52,212,241,0.15)');
                return g;
            })()
            : (() => {
                // Fallback: simple radial
                const g = ctx.createRadialGradient(CX, CY, 0, CX, CY, RADIUS);
                g.addColorStop(0, 'rgba(52,212,241,0.02)');
                g.addColorStop(0.5, 'rgba(52,212,241,0.05)');
                g.addColorStop(1, 'rgba(52,212,241,0.08)');
                return g;
            })();

        ctx.fillStyle = sweepFill;
        ctx.fill();

        // Sweep line
        ctx.beginPath();
        ctx.moveTo(CX, CY);
        ctx.lineTo(CX + Math.cos(sweepAngle) * RADIUS, CY + Math.sin(sweepAngle) * RADIUS);
        ctx.strokeStyle = 'rgba(52,212,241,0.5)';
        ctx.lineWidth = 1.5;
        ctx.shadowColor = '#34d4f1';
        ctx.shadowBlur = 8;
        ctx.stroke();
        ctx.shadowBlur = 0;
    }

    // ── Draw blips
    blips.forEach(b => {
        // Calculate angular distance from sweep
        let angleDiff = sweepAngle - b.angle;
        while (angleDiff < 0) angleDiff += Math.PI * 2;
        while (angleDiff > Math.PI * 2) angleDiff -= Math.PI * 2;

        // Blip was recently swept (within trail)
        const isFresh = angleDiff < 0.6 && angleDiff >= 0;
        const sweepFade = isFresh ? 1 - (angleDiff / 0.6) : 0;

        // Ping on sweep hit
        if (isFresh && angleDiff < 0.05 && b.hasSignal && now - b.pingTime > 3000) {
            b.pingTime = now;
            if (audioOn) playPing(b.signalStrength, b.signalType);
        }

        // Age-based fade (blips glow when recently swept)
        const pingAge = (now - b.pingTime) / 1000;
        const pingGlow = Math.max(0, 1 - pingAge / 4);

        const baseAlpha = b.hasSignal ? 0.4 : 0.15;
        const alpha = Math.min(1, baseAlpha + sweepFade * 0.6 + pingGlow * 0.4);

        if (alpha < 0.05) return; // Skip invisible blips

        const isHovered = hoveredBlip === b;
        const r = b.radius * (isHovered ? 1.8 : 1) + (b.hasSignal ? Math.sin(now * 0.005) * 1.5 : 0);

        // Signal blips get expanding ring
        if (b.hasSignal && pingGlow > 0.1) {
            const ringR = r + (1 - pingGlow) * 20;
            ctx.beginPath();
            ctx.arc(b.x, b.y, ringR, 0, Math.PI * 2);
            ctx.strokeStyle = hexToRGBA(b.color, pingGlow * 0.3);
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Outer glow
        if (alpha > 0.2) {
            const glow = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, r * 4);
            glow.addColorStop(0, hexToRGBA(b.color, alpha * 0.2));
            glow.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.beginPath();
            ctx.arc(b.x, b.y, r * 4, 0, Math.PI * 2);
            ctx.fillStyle = glow;
            ctx.fill();
        }

        // Core dot
        ctx.beginPath();
        ctx.arc(b.x, b.y, r, 0, Math.PI * 2);
        ctx.fillStyle = hexToRGBA(b.color, alpha);
        ctx.fill();

        // Bright center
        if (alpha > 0.3) {
            ctx.beginPath();
            ctx.arc(b.x, b.y, r * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = hexToRGBA('#ffffff', alpha * 0.5);
            ctx.fill();
        }

        // Label
        if (showLabels && (b.hasSignal || isHovered || alpha > 0.6)) {
            ctx.font = `${isHovered ? '600' : '400'} ${isHovered ? 10 : 8}px monospace`;
            ctx.fillStyle = hexToRGBA(b.color, Math.min(alpha + 0.2, 0.9));
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText((b.token.symbol || '').toUpperCase(), b.x, b.y - r - 3);
        }
    });

    // ── Center pip
    ctx.beginPath();
    ctx.arc(CX, CY, 3, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(52,212,241,0.4)';
    ctx.fill();

    // ── Hover tooltip
    detectHover();

    // ── Auto refresh
    if (now - lastFetch > FETCH_INTERVAL && lastFetch > 0) {
        fetchData();
    }
}

// ─── Mouse / hover ───────────────────────────────────────────────────────────
const tooltip = document.getElementById('tooltip');

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = SIZE / rect.width;
    const scaleY = SIZE / rect.height;
    mouseX = (e.clientX - rect.left) * scaleX;
    mouseY = (e.clientY - rect.top) * scaleY;
});

canvas.addEventListener('mouseleave', () => {
    mouseX = null; mouseY = null;
    hoveredBlip = null;
    tooltip.style.display = 'none';
});

function detectHover() {
    if (mouseX === null) return;

    let closest = null;
    let closestDist = Infinity;

    blips.forEach(b => {
        const dx = b.x - mouseX;
        const dy = b.y - mouseY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < Math.max(b.radius * 3, 15) && dist < closestDist) {
            closest = b;
            closestDist = dist;
        }
    });

    if (closest && closest !== hoveredBlip) {
        hoveredBlip = closest;
        showTooltip(closest);
    } else if (!closest) {
        hoveredBlip = null;
        tooltip.style.display = 'none';
    }
}

function showTooltip(blip) {
    const t = blip.token;
    document.getElementById('tt-name').textContent = `${(t.symbol || '').toUpperCase()} — ${t.name}`;
    document.getElementById('tt-price').textContent = '$' + fmtPrice(t.current_price);

    const ch = t.price_change_percentage_24h || 0;
    const chEl = document.getElementById('tt-change');
    chEl.textContent = (ch >= 0 ? '+' : '') + ch.toFixed(2) + '%';
    chEl.style.color = ch >= 0 ? '#00e87b' : '#ff6b6b';

    document.getElementById('tt-vol').textContent = '$' + fmtB(t.total_volume);
    document.getElementById('tt-mcap').textContent = '$' + fmtB(t.market_cap);

    const sig = signals.find(s => s.token.id === t.id);
    document.getElementById('tt-signal').textContent = sig ? `⚡ ${sig.message}` : `Sector: ${blip.sectorName}`;

    tooltip.style.display = 'block';

    // Position near canvas mouse
    const rect = canvas.getBoundingClientRect();
    const absX = rect.left + (blip.x / SIZE) * rect.width + 20;
    const absY = rect.top + (blip.y / SIZE) * rect.height - 20;
    tooltip.style.left = Math.min(absX, window.innerWidth - 270) + 'px';
    tooltip.style.top = Math.max(10, Math.min(absY, window.innerHeight - 180)) + 'px';
}

// ─── Controls ────────────────────────────────────────────────────────────────
document.getElementById('btn-sweep').addEventListener('click', function() {
    sweepRunning = !sweepRunning;
    this.classList.toggle('active', sweepRunning);
});

document.getElementById('btn-audio').addEventListener('click', function() {
    audioOn = !audioOn;
    if (audioOn) initAudio();
    this.querySelector('.material-symbols-rounded').textContent = audioOn ? 'volume_up' : 'volume_off';
    this.classList.toggle('active', audioOn);
});

document.getElementById('btn-labels').addEventListener('click', function() {
    showLabels = !showLabels;
    this.classList.toggle('active', showLabels);
});

document.getElementById('btn-filter').addEventListener('click', function() {
    const idx = FILTER_MODES.indexOf(filterMode);
    filterMode = FILTER_MODES[(idx + 1) % FILTER_MODES.length];
    this.childNodes[1].textContent = ' ' + (filterMode === 'all' ? 'All' : filterMode.charAt(0).toUpperCase() + filterMode.slice(1));
    renderSignalLog();
});

// ─── Utilities ───────────────────────────────────────────────────────────────
function fmtB(n) {
    if (n == null) return '—';
    if (n >= 1e12) return (n / 1e12).toFixed(2) + 'T';
    if (n >= 1e9) return (n / 1e9).toFixed(1) + 'B';
    if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
    if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
    return n.toFixed(0);
}

function fmtPrice(n) {
    if (n == null) return '—';
    if (n >= 1) return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
    if (n >= 0.01) return n.toFixed(4);
    return n.toFixed(6);
}

function hexToRGBA(hex, alpha) {
    if (hex.startsWith('rgba') || hex.startsWith('rgb')) {
        return hex.replace(/[\d.]+\)$/, alpha + ')');
    }
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r},${g},${b},${alpha})`;
}

// ─── Start ───────────────────────────────────────────────────────────────────
fetchData();
render();

</script>
</body>
</html>
