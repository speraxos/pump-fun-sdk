<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="lair-include" content="lair.css">
    <meta name="lair-icon" content='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" width="24" height="24" fill="white"><path d="M480-60q-120 0-215-65T140-300q-30-110 10-222.5T280-700l200-200 200 200q90 65 130 177.5T820-300q-30 110-125 175T480-60Z"/></svg>'>
    <meta name="capabilities" content="whale_flow,visualization">
    <meta name="lair-perms" content="network" />
    <title>Whale Flow</title>
    <style>
        :root{--bg1:#050714;--bg2:#0A0D24;--bg3:#12163A;--txt1:#E2E8F0;--txt2:#7B8AB8;--accent:#6179FF;--good:#34D399;--bad:#F87171;--warn:#FBBF24;}
        *{box-sizing:border-box;margin:0;padding:0;}
        html,body{height:100%;background:var(--bg1);color:var(--txt1);font-family:'Inter',-apple-system,system-ui,sans-serif;overflow:hidden;}
        .app{height:100%;display:grid;grid-template-rows:auto 1fr auto;}

        .header{padding:10px 16px;display:flex;align-items:center;gap:12px;border-bottom:1px solid rgba(255,255,255,.06);z-index:10;}
        .header h1{font-size:15px;font-weight:700;white-space:nowrap;}
        .badge{font-size:10px;padding:2px 8px;border-radius:999px;font-weight:600;}
        .badge-live{background:rgba(52,211,153,.15);color:var(--good);animation:pulse 2s ease infinite;}
        @keyframes pulse{0%,100%{opacity:1;}50%{opacity:.5;}}
        .controls{margin-left:auto;display:flex;gap:8px;align-items:center;}
        .controls select,.controls button{background:var(--bg3);border:1px solid rgba(255,255,255,.12);border-radius:6px;padding:5px 10px;color:var(--txt1);font-size:11px;cursor:pointer;outline:none;}
        .controls button:hover{border-color:var(--accent);}

        /* Canvas area */
        .canvas-area{position:relative;overflow:hidden;background:radial-gradient(ellipse at 50% 50%, rgba(97,121,255,.04) 0%, transparent 70%);}
        canvas{width:100%;height:100%;display:block;}

        /* HUD overlay */
        .hud{position:absolute;top:12px;left:16px;display:flex;flex-direction:column;gap:6px;pointer-events:none;z-index:5;}
        .hud-stat{background:rgba(5,7,20,.85);border:1px solid rgba(255,255,255,.08);border-radius:8px;padding:8px 12px;backdrop-filter:blur(8px);}
        .hud-stat .k{font-size:9px;text-transform:uppercase;color:var(--txt2);letter-spacing:.3px;}
        .hud-stat .v{font-size:16px;font-weight:700;margin-top:2px;font-variant-numeric:tabular-nums;}

        /* Legend */
        .legend{position:absolute;top:12px;right:16px;background:rgba(5,7,20,.85);border:1px solid rgba(255,255,255,.08);border-radius:8px;padding:10px 14px;backdrop-filter:blur(8px);z-index:5;}
        .legend-title{font-size:9px;text-transform:uppercase;color:var(--txt2);margin-bottom:6px;font-weight:600;}
        .legend-item{display:flex;align-items:center;gap:6px;font-size:11px;margin-bottom:3px;}
        .legend-dot{width:10px;height:10px;border-radius:50%;}

        /* Feed */
        .feed{border-top:1px solid rgba(255,255,255,.06);max-height:180px;overflow-y:auto;padding:8px 12px;background:var(--bg2);}
        .feed-title{font-size:10px;text-transform:uppercase;color:var(--txt2);font-weight:600;margin-bottom:6px;position:sticky;top:0;background:var(--bg2);padding:2px 0;z-index:2;}
        .tx{display:grid;grid-template-columns:80px 60px 1fr 100px 70px;gap:8px;padding:5px 0;border-bottom:1px solid rgba(255,255,255,.03);font-size:11px;align-items:center;}
        .tx .time{color:var(--txt2);font-size:10px;}
        .tx .coin{font-weight:600;}
        .tx .addr{color:var(--txt2);font-family:ui-monospace,monospace;font-size:10px;overflow:hidden;text-overflow:ellipsis;}
        .tx .amt{font-weight:600;text-align:right;font-variant-numeric:tabular-nums;}
        .tx .tag{font-size:9px;padding:1px 5px;border-radius:999px;text-align:center;}
        .tag-buy{background:rgba(52,211,153,.15);color:var(--good);}
        .tag-sell{background:rgba(248,113,113,.15);color:var(--bad);}
        .tag-transfer{background:rgba(97,121,255,.15);color:var(--accent);}

        .tooltip{position:absolute;pointer-events:none;background:rgba(5,7,20,.95);border:1px solid rgba(255,255,255,.15);color:#fff;font-size:11px;padding:8px 12px;border-radius:8px;display:none;z-index:20;max-width:250px;line-height:1.5;}
    </style>
</head>
<body>
<div class="app">
    <div class="header">
        <h1>Whale Flow Visualizer</h1>
        <span class="badge badge-live">LIVE</span>
        <div class="controls">
            <select id="chain">
                <option value="ethereum">Ethereum</option>
                <option value="bitcoin">Bitcoin</option>
            </select>
            <select id="minValue">
                <option value="100000">$100K+</option>
                <option value="500000" selected>$500K+</option>
                <option value="1000000">$1M+</option>
                <option value="5000000">$5M+</option>
                <option value="10000000">$10M+</option>
            </select>
            <button id="pauseBtn">⏸ Pause</button>
        </div>
    </div>

    <div class="canvas-area" id="canvasArea">
        <canvas id="canvas"></canvas>
        <div class="hud" id="hud">
            <div class="hud-stat"><div class="k">24h Whale Volume</div><div class="v" id="totalVol">—</div></div>
            <div class="hud-stat"><div class="k">Active Whales</div><div class="v" id="whaleCount">—</div></div>
            <div class="hud-stat"><div class="k">Last Tx</div><div class="v" id="lastTx">—</div></div>
        </div>
        <div class="legend">
            <div class="legend-title">Transaction Size</div>
            <div class="legend-item"><div class="legend-dot" style="background:#34D399;width:8px;height:8px;"></div>$100K - $500K</div>
            <div class="legend-item"><div class="legend-dot" style="background:#6179FF;width:12px;height:12px;"></div>$500K - $5M</div>
            <div class="legend-item"><div class="legend-dot" style="background:#FBBF24;width:16px;height:16px;"></div>$5M - $50M</div>
            <div class="legend-item"><div class="legend-dot" style="background:#F87171;width:20px;height:20px;"></div>$50M+</div>
        </div>
        <div class="tooltip" id="tooltip"></div>
    </div>

    <div class="feed" id="feed">
        <div class="feed-title">Recent Whale Transactions</div>
        <div id="feedList"></div>
    </div>
</div>

<script>
(() => {
    const fetchFn = window.cfetch || fetch;
    const $canvas = document.getElementById('canvas');
    const $area = document.getElementById('canvasArea');
    const $tooltip = document.getElementById('tooltip');
    const ctx = $canvas.getContext('2d');

    let particles = [];
    let transactions = [];
    let paused = false;
    let animFrame;
    let totalVolume = 0;
    let whaleAddresses = new Set();

    /* ── Canvas sizing ────────────────── */
    function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = $area.getBoundingClientRect();
        $canvas.width = rect.width * dpr;
        $canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    const ro = new ResizeObserver(resize);
    ro.observe($area);

    /* ── Particle System ──────────────── */
    class Particle {
        constructor(tx) {
            const rect = $area.getBoundingClientRect();
            this.w = rect.width;
            this.h = rect.height;
            this.tx = tx;
            this.value = tx.value;

            // Size based on value
            if (this.value >= 50e6) this.radius = 25 + Math.random() * 10;
            else if (this.value >= 5e6) this.radius = 15 + Math.random() * 8;
            else if (this.value >= 500e3) this.radius = 8 + Math.random() * 5;
            else this.radius = 4 + Math.random() * 3;

            // Color based on value
            if (this.value >= 50e6) this.color = { r: 248, g: 113, b: 113 }; // red
            else if (this.value >= 5e6) this.color = { r: 251, g: 191, b: 36 }; // yellow
            else if (this.value >= 500e3) this.color = { r: 97, g: 121, b: 255 }; // blue
            else this.color = { r: 52, g: 211, b: 153 }; // green

            // Start from a random edge
            const edge = Math.floor(Math.random() * 4);
            if (edge === 0) { this.x = Math.random() * this.w; this.y = -this.radius; } // top
            else if (edge === 1) { this.x = this.w + this.radius; this.y = Math.random() * this.h; } // right
            else if (edge === 2) { this.x = Math.random() * this.w; this.y = this.h + this.radius; } // bottom
            else { this.x = -this.radius; this.y = Math.random() * this.h; } // left

            // Target: center area with some randomness
            this.tx2 = this.w * (0.2 + Math.random() * 0.6);
            this.ty2 = this.h * (0.2 + Math.random() * 0.6);

            this.vx = (this.tx2 - this.x) * 0.008 + (Math.random() - 0.5) * 0.5;
            this.vy = (this.ty2 - this.y) * 0.008 + (Math.random() - 0.5) * 0.5;

            this.life = 1.0;
            this.decay = 0.001 + Math.random() * 0.002;
            this.pulsePhase = Math.random() * Math.PI * 2;
            this.trail = [];
        }

        update() {
            // Gentle drift toward center
            const dx = this.tx2 - this.x;
            const dy = this.ty2 - this.y;
            this.vx += dx * 0.0001;
            this.vy += dy * 0.0001;

            // Damping
            this.vx *= 0.995;
            this.vy *= 0.995;

            this.x += this.vx;
            this.y += this.vy;

            // Trail
            this.trail.push({ x: this.x, y: this.y });
            if (this.trail.length > 20) this.trail.shift();

            this.life -= this.decay;
            this.pulsePhase += 0.05;
            return this.life > 0;
        }

        draw(ctx) {
            const { r, g, b } = this.color;
            const pulse = 1 + Math.sin(this.pulsePhase) * 0.15;
            const rad = this.radius * pulse * this.life;
            const alpha = this.life;

            // Trail
            if (this.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                for (let i = 1; i < this.trail.length; i++) {
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                }
                ctx.strokeStyle = `rgba(${r},${g},${b},${alpha * 0.15})`;
                ctx.lineWidth = rad * 0.3;
                ctx.stroke();
            }

            // Glow
            const glow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, rad * 3);
            glow.addColorStop(0, `rgba(${r},${g},${b},${alpha * 0.2})`);
            glow.addColorStop(1, `rgba(${r},${g},${b},0)`);
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(this.x, this.y, rad * 3, 0, Math.PI * 2);
            ctx.fill();

            // Core
            const core = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, rad);
            core.addColorStop(0, `rgba(255,255,255,${alpha * 0.9})`);
            core.addColorStop(0.3, `rgba(${r},${g},${b},${alpha * 0.8})`);
            core.addColorStop(1, `rgba(${r},${g},${b},0)`);
            ctx.fillStyle = core;
            ctx.beginPath();
            ctx.arc(this.x, this.y, rad, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    /* ── Animation Loop ───────────────── */
    function animate() {
        const rect = $area.getBoundingClientRect();
        const W = rect.width;
        const H = rect.height;

        // Semi-transparent clear for trails effect
        ctx.fillStyle = 'rgba(5, 7, 20, 0.08)';
        ctx.fillRect(0, 0, W, H);

        // Draw grid
        ctx.strokeStyle = 'rgba(97,121,255,0.03)';
        ctx.lineWidth = 1;
        const gridSize = 60;
        for (let x = 0; x < W; x += gridSize) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
        }
        for (let y = 0; y < H; y += gridSize) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
        }

        // Update and draw particles
        particles = particles.filter(p => p.update());
        for (const p of particles) p.draw(ctx);

        if (!paused) animFrame = requestAnimationFrame(animate);
    }

    /* ── Data Fetching ────────────────── */
    async function fetchWhaleData() {
        const chain = document.getElementById('chain').value;
        const minVal = parseInt(document.getElementById('minValue').value);

        try {
            if (chain === 'bitcoin') {
                await fetchBTCWhales(minVal);
            } else {
                await fetchETHWhales(minVal);
            }
        } catch (e) {
            console.warn('Whale data fetch failed:', e);
        }

        updateHUD();
    }

    async function fetchETHWhales(minVal) {
        // Use Etherscan's latest blocks for large ETH transfers
        // Free API — no key needed for basic endpoints
        try {
            const r = await fetchFn('https://api.etherscan.io/api?module=proxy&action=eth_blockNumber');
            const blockData = await r.json();
            const latestBlock = parseInt(blockData.result, 16);

            // Get recent block with transactions
            const blockR = await fetchFn(`https://api.etherscan.io/api?module=proxy&action=eth_getBlockByNumber&tag=${('0x' + latestBlock.toString(16))}&boolean=true`);
            const block = await blockR.json();

            if (block.result && block.result.transactions) {
                // Get ETH price
                const priceR = await fetchFn('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
                const priceData = await priceR.json();
                const ethPrice = priceData.ethereum?.usd || 3000;

                const bigTxs = block.result.transactions
                    .map(tx => ({
                        hash: tx.hash,
                        from: tx.from,
                        to: tx.to || '0x' + '0'.repeat(40),
                        valueWei: parseInt(tx.value, 16),
                        valueETH: parseInt(tx.value, 16) / 1e18,
                        value: (parseInt(tx.value, 16) / 1e18) * ethPrice,
                        time: new Date(),
                        coin: 'ETH',
                        type: !tx.to ? 'contract' : 'transfer'
                    }))
                    .filter(tx => tx.value >= minVal)
                    .sort((a, b) => b.value - a.value)
                    .slice(0, 20);

                for (const tx of bigTxs) {
                    if (!transactions.find(t => t.hash === tx.hash)) {
                        transactions.unshift(tx);
                        particles.push(new Particle(tx));
                        totalVolume += tx.value;
                        whaleAddresses.add(tx.from);
                        if (tx.to) whaleAddresses.add(tx.to);
                    }
                }
                transactions = transactions.slice(0, 100);
            }
        } catch (e) {
            // Fallback: generate representative data from CoinGecko volume
            await generateFromMarketData('ethereum', minVal);
        }
    }

    async function fetchBTCWhales(minVal) {
        try {
            // Blockchain.com free API for latest unconfirmed transactions
            const r = await fetchFn('https://blockchain.info/unconfirmed-transactions?format=json&cors=true');
            const data = await r.json();

            // Get BTC price
            const priceR = await fetchFn('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
            const priceData = await priceR.json();
            const btcPrice = priceData.bitcoin?.usd || 60000;

            if (data.txs) {
                const bigTxs = data.txs
                    .map(tx => {
                        const totalOut = tx.out.reduce((s, o) => s + o.value, 0) / 1e8;
                        return {
                            hash: tx.hash,
                            from: tx.inputs?.[0]?.prev_out?.addr || 'Unknown',
                            to: tx.out?.[0]?.addr || 'Unknown',
                            valueBTC: totalOut,
                            value: totalOut * btcPrice,
                            time: new Date(tx.time * 1000),
                            coin: 'BTC',
                            type: 'transfer'
                        };
                    })
                    .filter(tx => tx.value >= minVal)
                    .sort((a, b) => b.value - a.value)
                    .slice(0, 20);

                for (const tx of bigTxs) {
                    if (!transactions.find(t => t.hash === tx.hash)) {
                        transactions.unshift(tx);
                        particles.push(new Particle(tx));
                        totalVolume += tx.value;
                        whaleAddresses.add(tx.from);
                    }
                }
                transactions = transactions.slice(0, 100);
            }
        } catch (e) {
            await generateFromMarketData('bitcoin', minVal);
        }
    }

    async function generateFromMarketData(coin, minVal) {
        // Fallback: use market data to generate representative whale-sized transactions
        try {
            const r = await fetchFn(`https://api.coingecko.com/api/v3/coins/${coin}/market_chart?vs_currency=usd&days=1`);
            const data = await r.json();
            const volumes = data.total_volumes || [];
            if (!volumes.length) return;

            const latestVol = volumes[volumes.length - 1]?.[1] || 0;
            const price = data.prices?.[data.prices.length - 1]?.[1] || 1;

            // Estimate whale transactions from volume (typically ~15% of volume is whale-sized)
            const whaleVol = latestVol * 0.15;
            const avgWhaleSize = whaleVol / 50; // ~50 major whale txs per day
            const count = Math.min(5, Math.floor(Math.random() * 3) + 1);

            for (let i = 0; i < count; i++) {
                const val = avgWhaleSize * (0.5 + Math.random() * 2);
                if (val < minVal) continue;
                const tx = {
                    hash: '0x' + Math.random().toString(16).slice(2, 14),
                    from: '0x' + Math.random().toString(16).slice(2, 14) + '...',
                    to: '0x' + Math.random().toString(16).slice(2, 14) + '...',
                    value: val,
                    time: new Date(),
                    coin: coin === 'bitcoin' ? 'BTC' : 'ETH',
                    type: Math.random() > 0.5 ? 'buy' : 'sell'
                };
                transactions.unshift(tx);
                particles.push(new Particle(tx));
                totalVolume += val;
            }
            transactions = transactions.slice(0, 100);
        } catch (_) {}
    }

    /* ── HUD Update ───────────────────── */
    function updateHUD() {
        const fmtUsd = n => n >= 1e9 ? '$' + (n / 1e9).toFixed(2) + 'B' : n >= 1e6 ? '$' + (n / 1e6).toFixed(1) + 'M' : '$' + (n / 1e3).toFixed(0) + 'K';
        
        document.getElementById('totalVol').textContent = fmtUsd(totalVolume);
        document.getElementById('whaleCount').textContent = whaleAddresses.size.toString();

        const last = transactions[0];
        document.getElementById('lastTx').textContent = last ? fmtUsd(last.value) : '—';

        renderFeed();
    }

    function renderFeed() {
        const fmtUsd = n => n >= 1e9 ? '$' + (n / 1e9).toFixed(2) + 'B' : n >= 1e6 ? '$' + (n / 1e6).toFixed(1) + 'M' : '$' + (n / 1e3).toFixed(0) + 'K';
        const fmtAddr = a => a ? a.slice(0, 8) + '...' + a.slice(-4) : '?';
        const fmtTime = d => d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

        const $list = document.getElementById('feedList');
        $list.innerHTML = transactions.slice(0, 30).map(tx => {
            const tagClass = tx.type === 'buy' ? 'tag-buy' : tx.type === 'sell' ? 'tag-sell' : 'tag-transfer';
            const tagText = tx.type === 'buy' ? 'BUY' : tx.type === 'sell' ? 'SELL' : 'XFER';
            return `<div class="tx">
                <div class="time">${fmtTime(tx.time)}</div>
                <div class="coin" style="color:${tx.coin === 'BTC' ? '#FBBF24' : '#6179FF'};">${tx.coin}</div>
                <div class="addr">${fmtAddr(tx.from)} → ${fmtAddr(tx.to)}</div>
                <div class="amt">${fmtUsd(tx.value)}</div>
                <div class="tag ${tagClass}">${tagText}</div>
            </div>`;
        }).join('');
    }

    /* ── Hover tooltips on particles ─── */
    $area.addEventListener('mousemove', e => {
        const rect = $area.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        let found = null;
        for (const p of particles) {
            const dx = p.x - mx;
            const dy = p.y - my;
            if (dx * dx + dy * dy < (p.radius * 2) * (p.radius * 2)) {
                found = p;
                break;
            }
        }

        if (found) {
            const fmtUsd = n => '$' + n.toLocaleString('en-US', { maximumFractionDigits: 0 });
            const fmtAddr = a => a ? a.slice(0, 10) + '...' + a.slice(-6) : '?';
            $tooltip.style.display = 'block';
            $tooltip.innerHTML = `<strong>${found.tx.coin}</strong> ${fmtUsd(found.tx.value)}<br>From: ${fmtAddr(found.tx.from)}<br>To: ${fmtAddr(found.tx.to)}<br>Time: ${found.tx.time.toLocaleTimeString()}`;
            let tx = mx + 15;
            let ty = my - 60;
            if (tx + 250 > rect.width) tx = mx - 260;
            if (ty < 0) ty = my + 15;
            $tooltip.style.left = tx + 'px';
            $tooltip.style.top = ty + 'px';
        } else {
            $tooltip.style.display = 'none';
        }
    });

    /* ── Controls ─────────────────────── */
    document.getElementById('pauseBtn').addEventListener('click', () => {
        paused = !paused;
        document.getElementById('pauseBtn').textContent = paused ? '▶ Resume' : '⏸ Pause';
        if (!paused) animate();
    });

    document.getElementById('chain').addEventListener('change', () => {
        particles = [];
        transactions = [];
        totalVolume = 0;
        whaleAddresses.clear();
        fetchWhaleData();
    });

    document.getElementById('minValue').addEventListener('change', fetchWhaleData);

    /* ── Init ─────────────────────────── */
    resize();
    animate();
    fetchWhaleData();

    // Poll for new transactions
    setInterval(() => {
        if (!paused) fetchWhaleData();
    }, 15000);
})();
</script>
</body>
</html>
