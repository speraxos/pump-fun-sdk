// Bare-mux v2 for PumpOS
// This is the minified index.js from @mercuryworkshop/bare-mux
// It provides BareMux.BareMuxConnection for setting transports
var BareMux=(()=>{var e=globalThis.fetch,t=globalThis.WebSocket,r=globalThis.SharedWorker,n=globalThis.localStorage,i=globalThis.navigator.serviceWorker,s=MessagePort.prototype.postMessage,a={prototype:{send:t.prototype.send},CLOSED:t.CLOSED,CLOSING:t.CLOSING,CONNECTING:t.CONNECTING,OPEN:t.OPEN};async function o(){let t=(await self.clients.matchAll({type:"window",includeUncontrolled:!0})).map(async e=>{let t=await c(e);return await l(t),t}),r=Promise.race([Promise.any(t),new Promise((e,t)=>setTimeout(t,1e3,new TypeError("timeout")))]);try{return await r}catch(e){if(e instanceof AggregateError)throw console.error("bare-mux: failed to get a bare-mux SharedWorker MessagePort as all clients returned an invalid MessagePort."),new Error("All clients returned an invalid MessagePort.");return console.warn("bare-mux: failed to get a bare-mux SharedWorker MessagePort within 1s, retrying"),await o()}}function c(e){let t=new MessageChannel;return new Promise(r=>{e.postMessage({type:"getPort",port:t.port2},[t.port2]),t.port1.onmessage=e=>{r(e.data)}})}function l(e){let t=new MessageChannel,r=new Promise((r,n)=>{t.port1.onmessage=e=>{e.data.type==="pong"&&r()},setTimeout(n,1500)});return s.call(e,{message:{type:"ping"},port:t.port2},[t.port2]),r}function u(e,t){let n=new r(e,"bare-mux-worker");return t&&i.addEventListener("message",t=>{if(t.data.type==="getPort"&&t.data.port){console.debug("bare-mux: recieved request for port from sw");let i=new r(e,"bare-mux-worker");s.call(t.data.port,i.port,[i.port])}}),n.port}var d=null;function h(){if(d===null){let e=new MessageChannel,t=new ReadableStream,r;try{s.call(e.port1,t,[t]),r=!0}catch(e){r=!1}return d=r,r}return d}class p{constructor(e){if(this.channel=new BroadcastChannel("bare-mux"),e instanceof MessagePort||e instanceof Promise)this.port=e;else this.createChannel(e,!0)}createChannel(e,t){if(self.clients)this.port=o(),this.channel.onmessage=e=>{e.data.type==="refreshPort"&&(this.port=o())};else if(e&&r){if(!e.startsWith("/")&&!e.includes("://"))throw new Error("Invalid URL. Must be absolute or start at the root.");this.port=u(e,t),console.debug("bare-mux: setting localStorage bare-mux-path to",e),n["bare-mux-path"]=e}else if(r){let e=n["bare-mux-path"];if(console.debug("bare-mux: got localStorage bare-mux-path:",e),!e)throw new Error("Unable to get bare-mux workerPath from localStorage.");this.port=u(e,t)}else throw new Error("Unable to get a channel to the SharedWorker.")}async sendMessage(e,t){this.port instanceof Promise&&(this.port=await this.port);try{await l(this.port)}catch{return console.warn("bare-mux: Failed to get a ping response from the worker within 1.5s. Assuming port is dead."),this.createChannel(),await this.sendMessage(e,t)}let r=new MessageChannel,n=[r.port2,...t||[]],i=new Promise((e,t)=>{r.port1.onmessage=r=>{let n=r.data;n.type==="error"?t(n.error):e(n)}});return s.call(this.port,{message:e,port:r.port2},n),await i}}class f{constructor(e){this.worker=new p(e)}async getTransport(){return(await this.worker.sendMessage({type:"get"})).name}async setTransport(e,t,r){await this.setManualTransport(`const { default: BareTransport } = await import("${e}");return [BareTransport, "${e}"];`,t,r)}async setManualTransport(e,t,r){if(e==="bare-mux-remote")throw new Error("Use setRemoteTransport.");await this.worker.sendMessage({type:"set",client:{function:e,args:t}},r)}getInnerPort(){return this.worker.port}}class m{constructor(e){this.worker=new p(e)}createWebSocket(t,r=[],n,i){try{t=new URL(t)}catch(e){throw new DOMException(`Failed to construct 'WebSocket': The URL '${t}' is invalid.`)}if(!["ws:","wss:"].includes(t.protocol))throw new DOMException(`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${t.protocol}' is not allowed.`);return Array.isArray(r)||(r=[r]),r=r.map(String),new g(t,r,this.worker,i=i||{})}async fetch(t,r){let n=new Request(t,r),i=r?.headers||n.headers,s=i instanceof Headers?Object.fromEntries(i):i,a=n.body,o=new URL(n.url);if(o.protocol.startsWith("blob:")){let t=await e(o),r=new Response(t.body,t);return r.rawHeaders=Object.fromEntries(t.headers),r.rawResponse={body:t.body,headers:Object.fromEntries(t.headers),status:t.status,statusText:t.statusText},r.finalURL=o.toString(),r}for(let t=0;;t++){let i=(await this.worker.sendMessage({type:"fetch",fetch:{remote:o.toString(),method:n.method,headers:s,body:a||void 0}},a?[a]:[])).fetch,c={status:i.status,statusText:i.statusText,headers:new Headers(i.headers)},l=new Response([101,204,205,304].includes(i.status)?void 0:i.body,c);if(l.rawHeaders=i.headers,l.rawResponse=i,l.finalURL=o.toString(),[301,302,303,307,308].includes(l.status)){let e=r?.redirect||n.redirect;switch(e){case"follow":{let e=l.headers.get("location");if(20>t&&e!==null){o=new URL(e,o);continue}throw new TypeError("Failed to fetch")}case"error":throw new TypeError("Failed to fetch");case"manual":return l}}else return l}}}class g extends EventTarget{constructor(e,t=[],r,n){super(),this.url=e.toString(),this.protocols=t;let i=e=>{this.protocols=e,this.readyState=a.OPEN,this.dispatchEvent(new Event("open"))},s=async e=>{this.dispatchEvent(new MessageEvent("message",{data:e}))},o=(e,t)=>{this.readyState=a.CLOSED,this.dispatchEvent(new CloseEvent("close",{code:e,reason:t}))},c=()=>{this.readyState=a.CLOSED,this.dispatchEvent(new Event("error"))};this.channel=new MessageChannel,this.channel.port1.onmessage=e=>{e.data.type==="open"?i(e.data.args[0]):e.data.type==="message"?s(e.data.args[0]):e.data.type==="close"?o(e.data.args[0],e.data.args[1]):e.data.type==="error"&&c()},r.sendMessage({type:"websocket",websocket:{url:e.toString(),protocols:t,requestHeaders:n,channel:this.channel.port2}},[this.channel.port2]),this.readyState=a.CONNECTING}send(...e){if(this.readyState===a.CONNECTING)throw new DOMException("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.");let t=e[0];t.buffer&&(t=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)),s.call(this.channel.port1,{type:"data",data:t},t instanceof ArrayBuffer?[t]:[])}close(e,t){s.call(this.channel.port1,{type:"close",closeCode:e,closeReason:t})}}return{BareMuxConnection:f,BareClient:m,WorkerConnection:p}})();
if(typeof self!=="undefined")self.BareMux=BareMux;
console.debug("bare-mux: BareMux loaded");
